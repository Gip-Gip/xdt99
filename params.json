{"name":"xdt99","tagline":"TI 99 Cross-Development Tools","body":"xdt99: TI 99 Cross-Development Tools\r\n====================================\r\n\r\nThe **TI 99 Cross-Development Tools** (xdt99) are a small suite of programs that\r\nfacilitate the development of programs for the TI 99 family of home computers on\r\nmodern computer systems.\r\n\r\nAs of this release, the cross-development tools comprise\r\n\r\n * `xas99`, a TMS9900 cross-assembler,\r\n * `xga99`, a GPL cross-assembler,\r\n * `xbas99`, a TI BASIC and TI Extended BASIC lister and encoder,\r\n * `xdm99`, a command-line disk manager for sector-based TI disk images, and\r\n * `xvm99`, a command-line volume manager for nanoPEB/CF7A Compact Flash cards.\r\n\r\nAll programs are written in Python and thus run on any platform that Python\r\nsupports, including Linux, Windows, and Mac OS X.\r\n\r\nThe [xdt99 homepage][1] is hosted on GitHub.  You can download the latest\r\n[binary release][2] of xdt99 or clone the entire source code [repository][3].\r\n\r\nThe xdt99 tools complement similar projects such as the excellent [TI Image\r\nTool][5] or the [TI 99/Sim emulator][6] by offering slightly different\r\napproaches or extending their platform availability.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nDownload the latest [binary release][2] from GitHub (recommended) or clone the\r\n[xdt99 repository][3].  Please note that the big download buttons on top of the\r\nxdt99 homepage on GitHub will include the entire repository; this is probably\r\n*not* what you want.\r\n\r\nYou will also need a working copy of [Python 2.x][4] installed on your computer.\r\n`xdt99` has been developed using Python 2.7, but other versions should work as\r\nwell.  Note, however, that compatibility with Python 3 has been postponed to a\r\nlater release for now.\r\n\r\nBoth cross-assemblers and the disk manager are self-contained Python programs\r\nthat may be used independently of each other.  The volume manager depends on the\r\ndisk manager and cannot be used without it.  For installation, simply place the\r\nfiles `xas99.py`, `xga99.py`, `xbas99.py`, `xdm99.py` and/or `xvm99.py`\r\nsomewhere into your `$PATH` or where your command-line interpreter will find\r\nthem.\r\n\r\nThe `example/` directory of the binary distribution contains some sample files\r\nthat are referenced throughout this manual.\r\n\r\n\r\nxas99 Cross-Assembler\r\n---------------------\r\n\r\nThe `xas99` cross-assembler translates TMS9900 assembly code into executable\r\nprograms for the TI 99 home computer equipped with the Editor/Assembler module\r\nor the Mini Memory module.\r\n\r\nInvoking `xas99` in standard mode will assemble a TMS9900 assembly source code\r\nfile into an object code file that may be loaded using the Editor/Assembler\r\nmodule option 3.\r\n\r\n\t$ xas99.py -R ashello.asm\r\n\r\n`xas99` also generates program image files for the Editor/Assembler module\r\noption 5 or RPK cartridge files suitable for the MESS emulator:\r\n\r\n\t$ xas99.py -R -i ashello.asm\r\n\t$ xas99.py -R -c ashello.asm\r\n\r\nAll existing assembly code for the TI 99, e.g., the Tombstone City source code\r\nshipped with the Editor/Assembler module, should cross-assemble using `xas99`\r\nwithout requiring any source code modifications.\r\n\r\nThe object code generated by `xas99` is identical to uncompressed object code\r\nproduced by the original TI Editor/Assembler package.  This includes all of its\r\nquirks, such as shortened object code lines or excessive address specifications,\r\nbut hopefully none of its bugs, such as invalid tags for certain `DEF`s.\r\n\r\nFor a detailed step-by-step example on how to cross-assemble and run an assembly\r\nprogram using the xdt99 tools and the MESS emulator please refer to the Example\r\nUsage section below.\r\n\r\nFinally, please note that even though the object code format of the TI 99 home\r\ncomputer shares many similarities with that of other TMS9900-based systems, most\r\nnotably the TI 990 mini computers, `xas99` currently targets the TI 99\r\nexclusively.\r\n\r\n\r\n### Assembling Source Code\r\n\r\nThe `xas99` cross-assembler reads an assembly source code file and generates an\r\nuncompressed object code file that is suitable for the original TI 99\r\nEditor/Assembler loader.\r\n\r\n\t$ xas99.py -R ashello.asm\r\n\t$ xas99.py -R ashello.asm -o HELLO-O\r\n\r\nThe output parameter `-o` may be used to override the default output filename.\r\n\r\nThe assembly options `-R` (register symbols), `-S` (symbol table), `-L`\r\n(listing), and `-C` (compressed object code) correspond to the respective\r\noptions of the TI Editor/Assembler module.  You will need to add `-R` if you\r\nprefer to write `MOV R0,*R1+` etc. instead of `MOV 0,*1+` in your source code.\r\n\r\nCurrently, only options `-R` and `-L` are supported; the other options are\r\nsilently ignored.\r\n\r\n`xas99` will report any errors to `stderr` during assembly.  Note that the\r\ngenerated object code may differ from the code generated by the Editor/Assembler\r\npackage in the case of errors.  `xas99` is slightly more permissive than the\r\nEditor/Assembler, but it should be able to assemble any source that the\r\nEditor/Assembler package can assemble.\r\n\r\n\r\n### Creating Program Images\r\n\r\nThe image parameter `-i` tells `xas99` to generate image files that can be\r\nloaded using Editor/Assembler option 5.\r\n\r\n\t$ xas99.py -R -i ashello.asm\r\n\r\nImages larger then 8 KB are split automatically into multiple files, using\r\nthe filename convention of the Editor/Assembler module.\r\n\r\nThe `-i` parameter simulates the `SAVE` utility program shipped with the\r\nEditor/Assembler package and honors the symbols `SFIRST` and `SLAST` to\r\ngenerate a single image for the entire memory area spanned by those two\r\naddresses.\r\n\r\nAlternatively, if either symbol is missing, `xas99` will generate separate\r\nimage files for each program segment defined in the assembly source code.\r\nFor example, the assembly of source file\r\n\r\n\t     AORG >A000\r\n\tL1   B @L2\r\n\t     AORG >B000\r\n\tL2   B @L1\r\n\r\nwill yield two images files of 10 bytes each instead of a single file of 4 KB.\r\nRelocatable segments will be relocated to memory locations `>A000` upwards.\r\n\r\nNote that the E/A loader for program files happily loads non-contiguous image\r\nfiles for individual program segments even though original `SAVE` utility does\r\nnot support this feature.\r\n\r\nAll the usual restrictions for program images apply.  In particular, the first\r\nword of the first image file must be an executable instruction.\r\n\r\n\r\n### Creating MESS Cartridges\r\n\r\nThe cartridge parameter `-c` tells `xas99` to create an RPK cartridge file that\r\ncan be used with the MESS emulator.\r\n\r\n\t$ xas99.py -R -c ascart.asm -n \"HELLO WORLD\"\r\n\r\nThe optional name parameter `-n` overrides the default name of the program that\r\nshows up in the TI 99 menu selection screen.\r\n\r\nThe resulting RPK archive is a ZIP file containing the actual program code plus\r\nvarious information for the MESS emulator on how to execute the program.\r\nTypically, RPK files are passed as arguments to the MESS executable, or they may\r\nbe mounted while running MESS using the emulator on-screen menu.\r\n\r\n\t$ mess64 ti99_4ae -cart ascart.rpk\r\n\r\nWhen the `-c` option is given, `xas99` will automatically generate suitable GPL\r\nheader information and relocate the program to address `>6030`, but it will not\r\nprocess the source code any further.  In particular, the usual restrictions on\r\nusing VDP memory access routines apply.\r\n\r\nNote that cartridge files cannot be generated from split image files.\r\n\r\n\r\n### Other Formats\r\n\r\nFor relocatable code not larger than around 24 KB, `xas99` can generate an\r\nExtended BASIC program that invisibly contains the generated code within:\r\n\r\n\t$ xas99.py --embed asembed.asm \r\n\r\nThe resulting program is a regular Extended BASIC program in so-called \"long\"\r\nformat that will execute the assembly code when run:\r\n\r\n\t>OLD DSK1.ASEMBED\r\n\t>RUN\r\n\r\nThus, the `--embed` options allows for the creation of assembly programs that do\r\nrequire the Editor/Assembler module for execution.\r\n\r\nThe generated Extended BASIC program will have only one visible line:\r\n\r\n\t1 CALL INIT :: CALL LOAD(163\r\n\t76,88,89,90,90,89,32,255,228\r\n\t):: CALL LOAD(8196,63,248)::\r\n\t CALL LINK(\"XYZZY\")\r\n\r\nBut be careful: editing the generated program is likely to corrupt the embedded\r\nassembly code!\r\n\r\n\r\n### Creating List Files\r\n\r\nThe `-L` option instructs `xas99` to generate a list file for the assembled\r\nsource code:\r\n\r\n\t$ xas99.py -R ashello.asm -L ashello.lst\r\n\r\nThe list file is useful for inferring the relative or absolute memory addresses\r\nof source code lines or the effective values of expressions.\r\n \r\nThe format of the list file is almost identical to that of the original\r\nEditor/Assembler module.  The most prominent difference is the listing of\r\nthe `BYTE` directive, where individual byte values are grouped into words.\r\n\r\n\r\n### TMS9900 Assembly Support\r\n\r\nThe `xas99` is a complete TMS9900 assembler supporting all documented TMS9900\r\nopcodes.  TMS9995 opcodes such as `MPYS` and `DIVS` are currently not supported\r\nbut may be added in a future release.\r\n\r\n`xas99` understands all assembler directives described in the Editor/Assembler\r\nmanual that are supported by both TI 99 assembler and loader, i.e.,\r\n\r\n\tDEF REF EQU DATA BYTE TEXT BSS BES AORG RORG DORG EVEN\r\n\tIDT DXOP COPY END\r\n\r\nNote that the `DORG` directive *is* supported, even though the TI assembler does\r\nnot do so.\r\n\r\nThe following directives are not supported by the TI 99 loader and are thus\r\nsilently ignored by `xas99`:\r\n\r\n\tPSEG PEND CSEG CEND DSEG DEND LOAD SREF\r\n\r\nListing generation is currently not supported, so directives\r\n\r\n\tLIST UNL PAGE TITL\r\n\r\nare also ignored.\r\n\r\n\r\n#### Source Code Organization\r\n\r\nThe `COPY` directive is used to break large assembly sources into individual\r\nfiles.\r\n\r\n`xas99` will search the current source directory for appropriately named source\r\nfiles.  For example, assembling\r\n\r\n\t$ xas99.py src/file1.asm\r\n\r\nwhere `file1.asm` contains the instruction `COPY \"DSK1.FILE2\"` will search for\r\ninclude files\r\n\r\n\tsrc/FILE2\r\n\tsrc/FILE2.ASM\r\n\tsrc/FILE2.S\r\n\r\nand its corresponding lower-case variants.  `COPY` also supports native file\r\npaths, e.g., `COPY \"/home/ralph/ti/src/file2.asm\"`.\r\n\r\n\r\n### `xdt99` Extensions\r\n\r\nThe `xas99` cross-assembler offers various \"modern\" extensions to the original\r\nTI Assembler to improve the developer experience for writing assembly programs.\r\nAll extensions are backwards compatible in virtually all situations of practical\r\nrelevance so that any existing source code should compile as-is.\r\n\r\nComments may be included anywhere in the source code by prepending them with a\r\nsemicolon `;`.  A `;` character inside a text literal `'...'` or filename\r\n`\"...\"` does *not* introduce a comment.\r\n\r\nSource code is processed case insensitively so that all labels, expressions, and\r\ninstructions may be written in upper case, lower case, or any mixture.  Text\r\nliterals are still case sensitive, though.\r\n\r\n\tlabel1 byte >A,>b\r\n\tLABEL2 TEXT 'Hello World'\r\n\tLabel3 mov Label1(R1),Label2(r2)\r\n\t\r\nLabels may be of arbitrary length and may contain arbitrary characters except\r\nfor whitespace and operators such as `;`, `+`, `*`, `(`, etc.\r\n\r\nThe use of whitespace has been relaxed.  Single spaces may be used judiciously\r\nwithin the operand field to increase the legibility of expressions.  Two or more\r\nspaces as well as tabs introduce the comment field.\r\n\r\n\tlabel  data addr + len - 1  comment\r\n\t       movb @addr + 2(r1), *r2+ ; comment\r\n\r\n(*Technical note*: It is not possible to detect the beginning of the comment\r\nfield based on the current instruction, as the example `LABEL EQU 1 * 2` shows.\r\nThe original TI Assembler parses `* 2` as comment, even though `1 * 2` is a\r\nvalid `EQU` expression.)\r\n\r\nThe extended expression syntax supports parentheses `(`, `)`, the modulo\r\noperator `%`, and binary operators bit-and `&`, bit-or `|`, bit-xor `^`, and\r\nbit-not `~`.\r\n\r\n\tarea    equ (xmax + 1) * (ymax + 1) \r\n\taddr2   equ addr1 | >A000 & ~>001F\r\n\tpadding bss size % 8\r\n\r\nIt is important to note that all operators have the *same precedence*, i.e., an\r\nexpression such as `1 + 2 * 3 - 4 & 5` evaluates as `(((1 + 2) * 3) - 4) & 5`.\r\nTo change the order of evaluation, parentheses can be used: `1 + (2 * 3) - (4 &\r\n5)`.  Changing the established order of evaluation would break the compatibility\r\nof `xas99` for existing sources.\r\n\r\nAn additional source preprocessor allows for conditional assembly based on\r\nwell-defined conditional expressions.\r\n\r\n\t       .ifdef lang_de\r\n\tmsg    text 'Hallo Welt'\r\n\t       .else\r\n\tmsg    text 'Hello World'\r\n\t       .endif\r\n\r\nThe preprocessor directives `.ifdef` and `.ifndef` check if a given symbol is\r\ndefined or not.  The directives equals `.ifeq`, not-equals `.ifne`, greater-than\r\n`.ifgt`, and greater-than-or-equals `.ifge` compare two arguments.  If the\r\nsecond argument is missing, the first argument is compared against value `0`.\r\n\r\nDirectives may be nested.  Valid conditional expressions and their rules of\r\nevaluation correspond to those of the `EQU` directive.  Additional symbols may\r\nbe supplied on the command line.\r\n\r\n\t$ xas99.py ashello.asm -D symbol1 symbol2=2\r\n\r\nIf no value is given, the symbol is set to value `1`.\r\n\r\nThe strictness option `-s` disables all `xas99`-specific extensions to improve\r\nbackwards compatibility for old sources:\r\n\r\n\t$ xas99.py -s ashello.asm\r\n\r\nNote, however, that case insensitivity cannot be disabled.\r\n\r\n\r\nxga99 GPL Cross-Assembler\r\n-------------------------\r\n\r\nThe `xga99` GPL cross-assembler translates programs written in TI's proprietary\r\nGraphics Programming Language into byte code that can be interpreted by the TI\r\n99 home computer.\r\n\r\nInvoking `xga99` in standard mode will assemble a GPL source code file into\r\nplain GPL byte code that may be placed in a physical or emulated GROM or GRAM\r\ndevice.\r\n\r\n\t$ xga99.py gahello.gpl\r\n\t$ xga99.py gahello.gpl -o gahello.bin\r\n\r\nThe output parameter `-o` may be used to override the default output filename,\r\nwhich uses extension `.gbc` (for \"GPL byte code\").\r\n\r\nThe image parameter `-i` tells `xga99` to generate suitable GPL header data for\r\nthe program so that the GPL byte code interpreter built into the TI 99 can\r\nexecute the image file.\r\n\r\n\t$ xga99.py -i gahello.gpl\r\n\r\n`xga99` will check if there is enough space at the beginning of the image file\r\nfor inserting GPL header data.  You may have to adjust (or remove) any `AORG`\r\ndirectives if there is not enough space available.\r\n\r\nProgram execution will start at the symbol provided with the `END` directive, or\r\nthe `START` symbol, or the first byte of the byte code, in this order.\r\n\r\nThe cartridge parameter `-c` relocates the GPL program to the cartridge GROM\r\narea, generates GPL header data, and packages the byte code image into a\r\ncartridge file suitable for the MESS emulator.\r\n\r\n\t$ xga99.py -c gahello.gpl\r\n\r\nThe resulting `.rpk` file may be executed as-is by the MESS emulator:\r\n\r\n\t$ mess64 ti99_4ae -cart gahello.rpk\r\n\r\nThe optional name parameter `-n` overrides the default name of the program that\r\nshows up in the TI 99 menu selection screen.\r\n\r\n\t$ xga99.py -c gahello.gpl -n \"HELLO GPL WORLD\"\r\n\r\nAs the Graphics Programming Language was never intended for public release,\r\nexisting native tools for assembling GPL source code differ substantially in the\r\nlanguage syntax they support.  `xga99` adopts a variation of the Ryte Data GPL\r\nAssembler syntax as its native format, but other syntax styles may be chosen\r\nwith the syntax parameter `-s`.\r\n\r\n\t$ xga99.py sdemo.gpl -s rag\r\n\r\nCurrently supported syntax styles are `xdt99` for the `xga99` native format,\r\n`rag` for the Ryte Data and R.A.G. GPL assemblers, and `mizapf` for the TI Image\r\nTool GPL disassembler.  Note that the original GPL syntax described in TI's *GPL\r\nProgrammer's Guide* was considered too arcane for inclusion in `xga99`.\r\n\r\nThe native `xdt99` syntax style is more \"modern\" in that it supports lower case\r\nsources and relaxes the use of whitespace.  For details, please refer to the\r\nrespective section of the `xas99` manual.\r\n\r\n\r\n### GPL Instructions\r\n\r\n`xga99` supports all GPL mnemonics described in the *GPL Programmer's Guide*.\r\nAs is common practice, however, the operand order for the shift instructions\r\n`SLL` etc. has been reversed from `Gd, Gs` to `Gs, Gd`.\r\n\r\nInstruction operands use the well-established prefix notation to address CPU\r\nRAM, VDP RAM, and GROM/GRAM, respectively:\r\n\r\n\t@<cpuram addr>  ....................  CPU RAM direct\r\n\t*<cpuram addr>  ....................  CPU RAM indirect\r\n\tV@<vdpram addr>  ...................  VDP RAM direct\r\n\tV*<cpuram addr>  ...................  VDP RAM indirect\r\n\t@<cpuram addr>(@<cpuram addr>)  ....  CPU RAM indexed\r\n\tV@<vdpram addr>(@<cpuram addr>)  ...  VDP RAM indexed\r\n\tG@<grom addr>  .....................  GROM/GRAM direct   (MOVE only)\r\n\tG@<grom addr>(@<cpuram addr>)  .....  GROM/GRAM indexed  (MOVE only)\r\n\t#<vdp reg>  ........................  VDP register       (MOVE only)\r\n\r\nNote that symbols do not imply a certain memory type, so references to GROM\r\naddresses in `MOVE` instructions still need to prepend `G@` to the symbol name:\r\n\r\n\tT1 TEXT 'HELLO'\r\n\tL1 MOVE 5,G@T1,V@100\r\n\r\nFor branch and call instructions, prefixing addresses by `G@` is optional, as\r\nbranch targets always reside in GROM/GRAM:\r\n\r\n\tB L1\r\n\tB G@L1\r\n\r\nInstruction operands may be complex expressions of symbols and literals.\r\nLiterals may be decimal numbers, hexadecimal numbers prefixed by `>`, binary\r\nnumbers prefixed by `:`, and text literals enclosed in single quotes `'`.\r\n\r\n\tBYTE 10, >10, :10, '1'\r\n\r\nExpressions are built using arithmeical operators `+`, `-`, `*`, `/`, `%`, and\r\n`**` and bit operators `&`, `|`, `^`, and `~`.  Expressions are evaluated\r\nleft-to-right with equal operator precedence; parentheses may be used to change\r\nthe order of evaluation.  For further details please refer to the `xas99`\r\nsection on expressions.\r\n\r\nBy default, `xga99` uses the following mnemonics for the `FMT` sub-language, but\r\nother syntax styles are available with the `-s` option:\r\n\r\n\tHTEXT/VTEXT <text>\r\n\tHCHAR/VCHAR <len>, <char>\r\n\tHMOVE <len>, <gs>\r\n\tROW/COL <n>\r\n\tROW+/COL+ <n>\r\n\tBIAS <n>/<gs>\r\n\tFOR <n> ... FEND [<label>]\r\n\r\nNote that unlike the Ryte Data GPL Assembler, `xga99` also supports the optional\r\naddress label for the `FEND` instruction.\r\n\r\n\r\n### GPL Directives\r\n\r\nThe `xga99` GPL assembler supports the following directives:\r\n\r\n\tGROM AORG EQU DATA BYTE TEXT STRI BSS TITLE COPY\r\n\r\nDirectives affecting listing generation are currently ignored:\r\n\r\n\tPAGE LIST UNL LISTM UNLM\r\n\r\nMost `xga99` directives work very similar to their `xas99` counterparts.\r\n\r\nThe `BYTE` and `DATA` directives insert bytes and words into the program,\r\nrespectively, irrespective of the size of their arguments.\r\n\r\n\tLABEL BYTE 1,>02,:11011010,'@',>100\r\n\t      DATA 1,>1000,'A'\r\n\r\nThe `TEXT` directive generates a sequence of bytes from a text literal or an\r\nextended hexadecimal literal.\r\n\r\n\tLABEL TEXT 'Groovin'' With GPL'\r\n\t      TEXT >183C7EFFE7C381\r\n\r\nNote that the second instruction is equivalent to `BYTE >18,>3C,>7E,...`.\r\n\r\nThe `STRI` directive works similar to the `TEXT` directive but prepends the\r\ngenerated byte sequence with a length byte.\r\n\r\nThe `GROM` directive sets the GROM base address for the code that follows.\r\nCurrently only one `GROM` directive per source file is supported.  Note that the\r\n`GROM` directive expects the actual GROM address, e.g., `>6000`, instead of an\r\ninteger number such as `3`.\r\n\r\nThe `AORG` directive is used to place individual code segments at specific\r\naddresses within the given GROM.  The address argument is thus relative to the\r\nGROM base address given by `GROM`.\r\n\r\nInstead of using the `GROM` and `AORG` directives in the source file the\r\nlocation of the final GPL byte code image may also be specified by command-line\r\nparameters `-G` and `-A`, respectively.  Note that cartridge parameter `-c`\r\nimplies `-G 0x6000` and `-A 0x30`.\r\n\r\n\r\nxbas99 TI BASIC and TI Extended BASIC Tool\r\n------------------------------------------\r\n\r\n`xbas99` is a command-line tool for converting TI BASIC and TI Extended BASIC\r\nprograms from source format to internal format, and vice versa.  For brevity, we\r\nwill refer to both TI BASIC and TI Extended BASIC programs simply as BASIC\r\nprograms.\r\n\r\nPrograms in source format are plain text files that contain the BASIC statements\r\nthat a user would usually type in.  These kind of text files are usually not\r\nstored on real TI 99 home computer systems.\r\n\r\nPrograms in internal format are TI-specific files in `PROGRAM` format that are\r\ngenerated by the `SAVE` command and understood by the `OLD` and `RUN` commands.\r\n`xbas99` also supports programs created in so-called long format `INT/VAR 254`\r\nand in merge format `DIS/VAR 163`.\r\n\r\nTypical use cases for `xbas99` include the listing of programs stored in\r\ninternal format and the creation of program files for the BASIC interpreter from\r\na text file with BASIC statements.\r\n\r\nThe list command `-l` lists the statements of a BASIC program in internal format on\r\nthe screen.  Formatting is identical to the built-in BASIC `LIST` command modulo\r\nthe line wrapping.\r\n\r\n\t$ xbas99.py -l bashello.bin\r\n\t10 REM HELLO\r\n\t20 INPUT \"YOUR NAME? \":NAME$\r\n\t30 PRINT \"HELLO \";NAME$\r\n\t40 END \r\n\r\nThe similar decode command `-d` saves the program listing to a file instead:\r\n\r\n\t$ xbas99.py -d bashello.bin\r\n\r\n`xbas99` uses extensions `.bas` for BASIC programs in source format and `.bin`\r\nfor programs in internal format.  To override the default naming convention, the\r\n`-o` argument may be used:\r\n\r\n\t$ xbas99.py -d bashello.bin -o sample_program.txt\r\n\r\nBASIC programs in long format are detected automatically.  To list programs in\r\nmerge format, simply add the merge option `--merge`.\r\n\r\nThe create command `-c` encodes a list of BASIC statements into internal format\r\nso that the resulting file can be loaded and run by the BASIC interpreter on a\r\nTI 99:\r\n\r\n\t$ xbas99.py -c bashello.bas\r\n\r\n`xbas99` assumes that the text file is stored in the native file format of the\r\nhost computer.  Each program line should be stored on a separate line, but the\r\njoin option `-j` may be used to automatically join split, i.e., word-wrapped,\r\nlines.\r\n\r\n\t$ xbas99.py -c bashello.txt -j <line-delta>\r\n\r\nAny line that does not begin with a number or whose supposed line number is not\r\nbetween the previous line number and the previous line number plus `line-delta`\r\nis considered a continuation of the previous line.\r\n\r\nThe long option `--long` instructs `xbas99` to create the program in long\r\nformat.  Long programs are stored within the 32 KB memory expansion and may be\r\nlarger than conventional programs.  For petty technical reasons, the creation of\r\nprograms in merge format is currently not supported.\r\n\r\nThe protection option `--protect` will add list protection to the generated\r\nprogram.  Programs with list protection cannot be listed or edited by the BASIC\r\ninterpreter.  Note, however, that the list command of `xbas99` will /not/ honor\r\nthe protection flag.\r\n\r\nProgram files created by `xbas99` are raw `PROGRAM` files that may have to be\r\ntransferred to a disk image or converted to TIFILES format before they can be\r\nused by an emulator or transferred to a real TI 99.  The `xdm99` tool covers\r\nboth of these operations:\r\n\r\n\t$ xdm99.py basic.dsk -a bashello.bin\r\n\t$ xdm99.py -T bashello.bin\r\n\r\nAdvanced users of xdt99 may also combine the creation of the BASIC program file\r\nand the transfer to a disk image in one single step:\r\n\r\n\t$ xbas99.py -c bashello.bas -o - | xdm99.py basic.dsk -a - -n HELLO\r\n\r\nAll tools in xdt99 follow the convention that the special filename `-` denotes\r\n`stdin` or `stdout`, respectively.  You can also pipe from `xdm99` into `xbas99`\r\nto list BASIC programs quickly that are stored on a disk image:\r\n\r\n\t$ xdm99.py basic.dsk -p HELLO | xbas99.py -l - \r\n\r\nFinally, `xbas99` does not distinguish between TI BASIC and TI Extended BASIC\r\nprograms.  To create a TI BASIC program that does not rely on the TI Extended\r\nBASIC module simply do not use any of the advanced Extended BASIC features such\r\nas `::` or subprograms like `SPRITE`.\r\n\r\nAlso note that the tool will read and encode any text file that you supply, with\r\nonly minimal syntax checking.  In other words, the resulting program file should\r\nalways load with `OLD`, but it may not `RUN`.  A future version of `xbas99` may\r\ncontain more advanced checks to assist developers in creating new BASIC\r\nprograms.\r\n\r\n\r\nxdm99 Disk Manager\r\n------------------\r\n\r\n`xdm99` is a command-line tool for cataloging and manipulating sector-based TI\r\ndisk images used by most emulators, including MESS.  `xdm99` also supports the\r\nTIFiles file format that retains TI-specific meta data for files that originate\r\nfrom TI disk images.\r\n\r\n\r\n### Cataloging Disks\r\n\r\nThe default operation of `xdm99` when invoked without any options is to print\r\nthe file catalog of the disk image to `stdout`:\r\n\r\n\t$ xdm99.py ed-asm.dsk\r\n\tED-ASSM   :     97 used  263 free   90 KB  1S/1D  40 TpS\r\n\t----------------------------------------------------------------------------\r\n\tASSM1         33  PROGRAM       8192 B\r\n\tASSM2         18  PROGRAM       4102 B\r\n\tEDIT1         25  PROGRAM       5894 B\r\n\tSAVE          13  DIS/FIX 80    3072 B   36 recs\r\n\tSFIRST/O       3  DIS/FIX 80     512 B    5 recs\r\n\tSLAST/O        3  DIS/FIX 80     512 B    4 recs\r\n\r\nThe top line shows the name of the disk, the number of used and free sectors as\r\nwell as the disk geometry.  For each file, the number of used sectors, the file\r\ntype, the file length, and the actual number of records is shown.  If present,\r\nthe file modification time is also shown.\r\n\r\n`xdm99` will warn about any inconsistencies it may find, e.g., blocks claimed by\r\nfiles but not allocated in the allocation map.  When assembling programs\r\nnatively these inconsistencies happen more frequently than one would assume.\r\nFiles affected by inconsistencies are flagged with `ERR` in the catalog.  You\r\ncan try the `-R` option to automatically repair disks with inconsistencies.\r\n\r\n\r\n### Extracting Files\r\n\r\nThe extract parameter `-e` extracts one or more files from a disk image to the\r\nlocal file system.\r\n\r\n\t$ xdm99.py work.dsk -e HELLO-S CART-S\r\n\r\nThe local output filename is derived automatically from the TI filename but\r\nmay be overridden with the `-o` parameter if only one file is extracted.\r\n\r\n\t$ xdm99.py work.dsk -e HELLO-S -o hello.asm\r\n\r\nTo print the contents of a file to `stdout`, the print parameter `-p` may also\r\nbe used:\r\n\r\n\t$ xdm99.py work.dsk -p HELLO-S\r\n\r\nIn general, printing files only makes sense for files in DIS/FIX or DIS/VAR\r\nformat.  Following Unix conventions, `-p` is equivalent to combining parameters\r\n`-e` and `-o \"-\"`.\r\n\r\nFilenames given by `-e` may be glob patterns containing wildcards `*`\r\nand `?`.  This will extract all files matching the given pattern.\r\n\r\n\t$ xdm99.py work.dsk -e \"HELLO-*\"\r\n\r\nNote that you may have to quote your glob pattern to prevent your\r\nshell from expanding the pattern prematurely.\r\n\r\nExtracting files will yield the file contents only.  In order to\r\nretain file meta data about file type and record length, use the\r\nTIFiles or v9t9 formats described below.\r\n\r\n\r\n### Manipulating Disks\r\n\r\nThe add parameter `-a` adds local files to the disk image.  `xdm99` will infer a\r\nsuitable TI filename from the local filename unless an explicit filename is\r\ngiven by the `-n` parameter.  If the file is not of type `PROGRAM`, the file\r\ntype must be given using the `-f` parameter.\r\n\r\n\t$ xdm99.py work.dsk -a ashello.asm -n HELLO-S -f DIS/VAR80\r\n\r\nThe syntax for `-f` is fairly permissible, e.g., `DIS/FIX 80`, `DISFIX80`, or\r\n`DF80` all work.\r\n\r\nWhen adding multiple files with the `-n` option, the last character of the\r\nspecified filename will be incremented by one for each subsequent file, e.g.,\r\n \r\n\t$ xdm99.py work.dsk -a intro main appendix -n FILE\r\n\r\nwill add the files as `FILE`, `FILF`, and `FILG` to the disk image.\r\n\r\nThe rename parameter `-r` renames one or more files on the disk.\r\n\r\n\t$ xdm99.py work.dsk -r HELLO-S:HELLO/S\r\n\r\nFor each file to rename, provide the old filename. followed by a colon `:`,\r\nfollowed by the new filename. \r\n\r\nThe delete parameter `-d` deletes one or more files on the disk.\r\n\r\n\t$ xdm99.py work.dsk -d HELLO-I HELLO-O\r\n\t$ xdm99.py work.dsk -d \"*-O\"\r\n\r\nNote that the current implementation of `xdm99` does not perform a \"secure\r\nerase\", i.e., parts of the file contents may remain hidden in the sectors of the\r\ndisk image.\r\n\r\nFile operations do not retain the overall sector structure of the disk.  In\r\nparticular, all files will be defragmented whenever files are added or deleted\r\nwith `-a` or `-d`, respectively, or when the disk is repaired with `-R`.  Simply\r\ncataloging the disk, however, will *not* modify the disk image.\r\n\r\nBy default, all modifying disk operations will change the disk image directly.\r\nTo create an independent copy of the original disk image with the changes\r\napplied, the `-o` parameter may be used.\r\n\r\n\r\n### Files in a Directory (FIAD)\r\n\r\nExtracting files from a TI disk image to the local file system will lose certain\r\nTI-specific file information, such as the file type or the record length.  In\r\norder to retain this meta information along with the file contents, the v9t9 and\r\nTIFiles formats were created.  The approach of storing TI files directly on the \r\nlocal file system instead of using a disk image is also known as \"files in a\r\ndirectory\" (FIAD).\r\n\r\n`xdm99` supports the TIFiles format and the v9t9 format for FIAD files by using \r\nthe `-t` and `-9` options, respectively.  To extract a file in either FIAD \r\nformat, simply add `-t` or `-9` to the extract operation:\r\n\r\n\t$ xdm99.py work.disk -t -e HELLO-S\r\n\t$ xdm99.py work.disk -9 -e HELLO-S\r\n\r\nBy default, files extracted in TIFiles or v9t9 format will have extension `.tfi`\r\nor `.v9t9`, respectively.\r\n\r\nTo add a file in TIFiles format or v9t9 format, add `-t` or `-9` to the add\r\noperation:\r\n\r\n\t$ xdm99.py work.disk -t -a hello-s.tfi\r\n\t$ xdm99.py work.disk -9 -a hello-s.v9t9\r\n\r\nNote that for safety reasons `xdm99` will not infer the file type automatically,\r\nso adding a FIAD file without `-t` or `-9` option will incorrectly store the\r\nfile metadata as part of the file contents.\r\n\r\nAs all information about the TI filename and the TI file format is retrieved\r\nfrom the FIAD meta data, parameters `-n` and `-f` are ignored when used in\r\ncombination with `-t` or `-9`.\r\n\r\nThe info parameter `-I` displays the meta file information contained in FIAD\r\nfiles, while the print parameter `-P` dumps the file contents to\r\n`stdout`:\r\n\r\n\t$ xdm99.py -I hello-s.tfi\r\n\t$ xdm99.py -P hello-s.v9t9\r\n\r\n \r\n`xdm99` can also convert from FIAD files to plain files and vice versa without \r\nrelying on disk images using the `-T` and `-F` parameters:\r\n\r\n\t$ xdm99.py -F hello-s.tfi\r\n\t$ xdm99.py -T hello.asm -f DIS/VAR80 -n HELLO-S -o hello-s.tfi\r\n\r\nNote that creating a FIAD file using the `-T` option usually requires\r\ninformation about the TI filename and the TI file type, similar to adding plain\r\nfiles to a disk image using `-a`.  When converting multiple files to FIAD\r\nformat, the TI filename supplied by `-n` is incremented automatically for each \r\nfile.\r\n\r\nFIAD file conversion `-T`, `-F` and information `-I` and `-P` infer the FIAD\r\nformat used automatically, but detection may be overridden with the `-t` or\r\n`-9` options.\r\n\r\n\r\n### Analyzing Disks\r\n\r\nThe check parameter `-C` analyzes a disk image for errors and prints a summary\r\nto `stderr`.  While all disk operations, including cataloging, also check and\r\nreport any disk errors found, the `-C` parameter restricts the output of `xdm99`\r\nto those errors only.\r\n\r\n\t$ xdm99.py -C work.dsk\r\n\r\nThe `-C` parameter also causes `xdm99` to set its return value to non-zero for\r\nwarnings, making it simple to write shell scripts for batch processing bad disk\r\nimages.\r\n\r\nThe repair option `-R` tries to fix any disk errors, mostly by deleting\r\nerroneous files from it.\r\n\r\n\t$ xdm99.py -R work.dsk\r\n\r\nThe repair operation is likely to cause data loss, so it's best to extract\r\nerroneous files beforehand or to specify an alternative output file with `-o`.\r\n\r\nThe `--initialize` parameter creates a new, blank disk image, using an\r\noptional name provided by `-n`.\r\n\r\n\t$ xdm99.py blank.dsk --initialize 720 -n BLANK\r\n\r\nThe size of the disk image is given by the number of sectors.  You may\r\nalso use the aliases `SSSD`, `DSSD`, `DSDD`, and `CF` for sector\r\ncounts of 360, 720, 1440, and 1600, respectively.  Note that the disk\r\nformat used by the TI 99 supports up to 1600 sectors per disk.\r\n\r\nThe resize parameter `-Z` will change the total number of sector of\r\nthe disk without changing the contents of the files currently stored.\r\n\r\n\t$ xdm99.py work.dsk -Z 720\r\n\r\nResizing fails if more sectors than the target size are currently in use.\r\n\r\nThe sector dump parameter `-S` prints the hexadecimal contents of individual\r\nsectors to `stdout`.  This can be used to further analyze disk errors or to save\r\nfragments of corrupted files.\r\n\r\n\t$ xdm99.py work.dsk -S 1\r\n\t$ xdm99.py work.dsk -S 0x22 -o first-file-sector\r\n\t\r\nFor convenience, the arguments of `-Z` and `-S` may be specified in either\r\ndecimal or hexadecimal notation.\r\n\r\n\r\nxvm99 Volume Manager\r\n--------------------\r\n\r\n`xvm99` is an extension to the `xdm99` tool specifically for the\r\nnanoPEB/CF7A-kind of devices that simulate TI floppy drives using Compact Flash\r\ncards.  `xvm99` manages and manipulates the disk images stored in the individual\r\nvolumes of CF cards.\r\n\r\n\r\n### Managing Volumes\r\n\r\nThe default operation of `xvm99` when invoked without any command arguments is\r\nto print a short summary of the disk images stored in the specified volumes.\r\n\r\n\t$ xvm99.py /dev/sdc 1-4,8\r\n\t[   1]  EXTBASIC  :     4 used  1596 free\r\n\t[   2]  EMPTY     :     2 used  1598 free\r\n\t[   3]  SSSD      :    39 used  1561 free\r\n\t[   4]  INFOCOM   :   459 used  1141 free\r\n\t[   8]  (not a valid disk image)\r\n\r\nThe first argument is the name of your Compact Flash card drive, i.e., something\r\nlike `/dev/sdc` on Linux, `/dev/Disk3` on Mac OS X, or `\\\\.\\PHYSICALDRIVE2` on\r\nWindows.  **Caution:** These are examples only; make sure to identify your CF\r\ncard device correctly, *or you will lose data!* Also note that your user needs\r\nappropriate read and/or write permissions to access the device.\r\n\r\nThe second argument may be a single volume number or a combination of value\r\nranges, e.g., `1,3-4,6-10`.  In general, if more than one volume is specified,\r\nthen the command is applied to *all* volumes.\r\n\r\nThe `-w` parameter writes a disk image to one or more volumes.\r\n\r\n\t$ xvm99.py /dev/sdc 1,3 -w work.dsk\r\n\r\n`xvm99` automatically extends the disk image to match the 1600 sector format\r\nused by the CF7A device, unless the `--keep-size` option is given.\r\n\r\nThe `-r` argument reads a disk image from a volume and stores it on the local\r\nfile system.\r\n\r\n\t$ xvm99.py /dev/sdc 2 -r vol2.dsk\r\n\r\nWhen reading from multiple volumes the resulting disk images will be renamed\r\nautomatically.  `xvm99` trims disk images to match the sector count stored in\r\nthe image, unless the `--keep-size` option is given.\r\n\r\n\r\n### Manipulating Volumes\r\n\r\nMost commands provided by `xdm99` are also available for `xvm99`.\r\n\r\nFor example, to catalog a volume, you use the same `-i` command as for `xdm99`:\r\n\r\n\t$ xvm99.py /dev/sdc 8 -i\r\n\r\nOther commands supported by `xvm99` are print files `-p`, extract files `-e`,\r\nadd files `-a`, delete files `-d`, check disk `-c`, and repair disk `-R`.\r\n\r\nAgain, if more than one volume is specified, then the command is applied to all\r\nvolumes.  For example,\r\n\r\n\t$ xvm99.py /dev/sdc 1-20 -a README -f DV80\r\n\r\nadds the local file README to all disk images in volumes 1 through 20.\r\n\r\n\r\nExample Usage\r\n-------------\r\n\r\nThis section gives an example on how to assemble a TI 99 assembly program and\r\nrun it on the MESS emulator.  The commands entered and the responses shown here\r\noriginate from a Linux system, but they should look very similar on Windows and\r\nMac OS X machines.\r\n\r\nThe binary distribution of xdt99 contains an `example` folder with some sample\r\nfiles that we're going to use.  For the source distribution available on Github\r\nthese files are located under the `test` folder.\r\n\r\n\t$ cd example/\r\n\t$ ls -l\r\n\t-rw-rw---- 1 ralph ralph  1822 Jan 10 12:51 ascart.asm\r\n\t-rw-rw---- 1 ralph ralph   925 Jan 10 12:32 ashello.asm\r\n\t-rw-rw---- 1 ralph ralph 92160 Jan 10 12:33 work.dsk\r\n\t\r\nThe file `ashello.asm` contains a simple assembly program that we want to\r\nassemble and run.  Since the program uses register symbols like `R0` to refer to\r\nregisters, we need to specify the `-R` option for assembly.\r\n\r\n\t$ xas99.py -R ashello.asm\r\n\r\nThis should yield an object code file `ashello.obj` that looks like\r\nthis:\r\n\r\n\t0007EASHELLO A0000B100DB4845B4C4CB4F20B574FB524CB4420B2020B68697F19FF       0001\r\n\tA0012B7420B616EB7920B6B65B7921B0300B0000B02E0B8300B04C0B02017F2F9F          0002\r\n\tA0028B2A20B0202B0300B0420B0000B0580B0602B16FBB0200B0043B02017F336F          0003\r\n\tA003EC0002B0202B001AB0420B0000B0208BFF00B04C9B0300B0002B10007F31FF          0004\r\n\tA0054B0300B0000BD809B837CBD809B8374B0420B0000B9220B8375B13F97F2D4F          0005\r\n\tA006ABD020B8375B0980B0240B000FB0260B0700B0420B0000B10E87F410F               0006\r\n\t50000SLOAD 50000SFIRST5007ESLAST 5001CSTART 30030VSBW  7F28AF               0007\r\n\t30046VMBW  3007AVWTR  30062KSCAN 7F827F                                     0008\r\n\t:       99/4 AS                                                             0009\r\n\r\nThis file can be loaded with the Editor/Assembler module using option 3.  But\r\nbefore we start MESS, we'll also generate an image file for option 5:\r\n\r\n\t$ xas99.py -R -i ashello.asm\r\n\r\nThis time we should get a binary file `ashello.img` of 132 bytes.\r\n\r\n\t$ ls -l ashello.img\r\n\t-rw-rw---- 1 ralph ralph   132 Jan 10 13:11 ashello.img\r\n\r\nWe now need to transfer these files to a TI disk image so that the TI 99\r\nemulated by MESS can load it.  We'll use the SS/SD disk image `work.dsk` that is\r\nincluded in the example folder of xdt99 for convenience:\r\n\r\n\t$ xdm99.py work.dsk -a ashello.obj -n HELLO-O -f DIS/FIX80\r\n\t$ xdm99.py work.dsk -a ashello.img -n HELLO-I\r\n\t$ xdm99.py work.dsk\r\n\tWORK      :     8 used  352 free   90 KB  1S/1D  40 TpS\r\n\t----------------------------------------------------------------------------\r\n\tHELLO-I        2  PROGRAM        132 B            2015-01-10 13:15:18\r\n\tHELLO-O        4  DIS/VAR 80     755 B    9 recs  2015-01-10 13:15:10\r\n\r\nWe start MESS with our work disk inserted in floppy drive 1:\r\n\r\n\t$ mess64 ti99_4ae -peb:slot2 32kmem -peb:slot8 hfdc -cart EA.rpk -flop1 work.dsk\r\n\r\nYou may have to adjust the command for starting MESS based on the location of\r\nyour Editor/Assembler cartridge file.  When using a graphical frontend to launch\r\nMESS, use your GUI to select the Editor/Assembler module and the disk image\r\npreviously created.\r\n\r\nOn the TI 99/4A startup screen, we hit any key, then select the Editor/Assembler\r\nmodule.  We select option 3, `LOAD AND RUN`, then enter the name of the object\r\ncode file at the `FILE NAME?` prompt:\r\n\r\n\tDSK1.HELLO-O\r\n\r\nOnce the loader finishes, we hit `ENTER` to advance to the `PROGRAM NAME?`\r\nprompt, and type `START` to start the program.  The words \"HELLO WORLD\" should\r\nappear on screen, and hitting any key will change the color of the screen\r\nborder.\r\n\r\nWhen done, we quit the program by hitting `FCTN =`.  Again we select the\r\nEditor/Assembler module, but now we select option 5, `RUN PROGRAM FILE`.  We\r\nenter the name of the image file:\r\n\r\n\tDSK1.HELLO-I\r\n\r\nThe program will start automatically once loading has completed.\r\n\r\nIf we want to learn more about the internals of our assembled program we can\r\ntake a look at its list file: \r\n\r\n\t$ xas99.py -R ashello.asm -L ashello.lst\r\n\r\nThis yields a text file `ashello.lst` that begins like this:\r\n\r\n\tXAS99 CROSS-ASSEMBLER   VERSION 1.2.3\r\n\t0001            *  HELLO WORLD\r\n\t0002            \r\n\t0003                   IDT 'ASHELLO'\r\n\t0004            \r\n\t0005                   DEF SLOAD,SFIRST,SLAST,START\r\n\t0006                   REF VSBW,VMBW,VWTR\r\n\t0007                   REF KSCAN\r\n\t0008            \r\n\t0009            SLOAD\r\n\t0010 0000 100D  SFIRST JMP  START\r\n\t0011            \r\n\t0012      8300  WRKSP  EQU  >8300\r\n\t0013      8374  KMODE  EQU  >8374\r\n\t0014      8375  KCODE  EQU  >8375\r\n\t0015      837C  GPLST  EQU  >837C\r\n\t0016            \r\n\t0017 0002 ....  MESSG  TEXT 'HELLO WORLD'\r\n\t0018 000D ....         TEXT '   hit any key!'\r\n\t0019      001A  MESSGL EQU  $-MESSG\r\n\t0020            \r\n\t0021 001C 0300  START  LIMI 0\r\n\t     001E 0000 \r\n\t0022 0020 02E0         LWPI WRKSP\r\n\t     0022 8300\r\n\t...\r\n\r\nThe first column shows the line number of our source file.  As we can see, some\r\nsource file lines may produce more than one list file lines.  The second and\r\nthird columns show the memory location and its contents, respectively.  Some\r\ndirectives such as `EQU` do not correspond to a memory location, so their\r\nsecond and third columns may show other relevant information instead.\r\n\r\nTo run assembly programs without the Editor/Assembler module, we finally\r\ngenerate our own self-contained cartridge.\r\n\r\nFirst we need to assemble our source code using the `-c` option.\r\n\r\n\t$ xas99.py -R -c ascart.asm -n \"HELLO CART\"\r\n\r\nNote that we cannot run the `ashello.asm` program as a cartridge, since we call\r\n`VSBW` and other VDP subroutines, which are unavailable without Editor/Assembler\r\nmodule and memory expansion.  The `ascart.asm` program thus uses the VDP\r\nregisters directly to write to VDP memory.\r\n\r\nWe don't have to transfer the resulting RPK file to a disk image but can plug\r\nthe cartridge directly into the MESS emulator:\r\n\r\n\t$ mess64 ti99_4ae -cart ascart.rpk\r\n\r\nAfter pressing any key on the TI 99 startup screen you should now see \"HELLO\r\nCART\" as the second option on the menu screen.  Pressing 2 will run the sample\r\nprogram.\r\n\r\nNote that the programs runs without the 32K memory expansion, as the\r\nprogram code is stored inside a virtual cartridge ROM.\r\n\r\nIf we want to run our sample program on a real TI 99 using the CF7A flash drive,\r\nwe need to transfer our disk image to a flash card first:\r\n\r\n\t$ xvm99.py /dev/sdc 2 -w work.dsk\r\n\r\nThis will make our work disk from above available as volume 2 on the CF7A, where\r\nit can be accessed as `DSK2` by default on the TI 99.  If we don't want to\r\nreplace the entire disk contents of volume 2 we could also just transfer the\r\nfile instead.\r\n\r\n\t$ xvm99.py /dev/sdc 2 -a ashello.obj -n HELLO-O -f DIS/FIX80\r\n\r\nEither way, `ashello.obj` will be available as `HELLO-O` in volume 2 and can\r\nloaded as `DSK2.HELLO-O` by the Editor/Assembler module.\r\n\r\n\r\n### Building Cartridges With GPL\r\n\r\nThis subsection shows how we can use the `xga99` GPL cross-assembler to assemble\r\nGPL programs into virtual cartridges that run in any TI 99 emulator.  (With the\r\nright device such as a GRAM Kracker this exercise would even work on a physical\r\nTI computer!)\r\n\r\nThe `example/` directory included with xdt99 contains a small GPL program\r\n`gahello.gpl` that sets some sprites in motion, shows a simple animation in\r\nnormal graphics mode, and plays a simple tune.\r\n\r\nIf you're using the MESS emulator running the sample program is very easy:\r\n\r\n\t$ xga99.py -c gahello.gpl\r\n\t$ mess64 ti99_4ae -cart gahello.rpk\r\n\r\nInside the TI 99 emulation, you'll find a menu entry for the cartridge program\r\non the TI menu selection screen.\r\n\r\nFor other emulators you'll probably need to work with the plain GPL image file\r\ninstead:\r\n\r\n\t$ xga99.py -i gahello.gpl -G 0x6000 -A 0x20\r\n\r\nThis yields the file `gahello.bin` that contains the GPL byte code with suitable\r\nheader data for the GPL interpreter of the TI 99.  The `-G` and `-A` options\r\ntell `xga99` that we want to place the byte code into a cartridge GROM.\r\n\r\nTo run the sample program, load `gahello.bin` as a cartridge into your emulator\r\nand reset the virtual TI 99.  Again, you should find an entry for the program on\r\nthe TI menu selection screen.\r\n\r\n\r\nFeedback and Bug Reports\r\n------------------------\r\n\r\nThe xdt99 tools are released under the GNU GPL, in the hope that TI 99\r\nenthusiasts may find them useful.\r\n\r\nFor feedback, bug reports, and feature requests the developer can be reached at\r\n<xdt99dev@gmail.com>.\r\n\r\n\r\n[1]: https://endlos99.github.io/xdt99\r\n[2]: https://github.com/endlos99/xdt99/releases\r\n[3]: https://github.com/endlos99/xdt99\r\n[4]: https://www.python.org/downloads/\r\n[5]: http://www.mizapf.de/ti99/tiimagetool.html\r\n[6]: http://www.mrousseau.org/programs/ti99sim/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}