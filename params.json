{
  "name": "xdt99",
  "tagline": "TI 99 Cross-Development Tools",
  "body": "xdt99: TI 99 Cross-Development Tools\r\n====================================\r\n\r\nThe **TI 99 Cross-Development Tools** (xdt99) are a small suite of programs that\r\nfacilitate the development of programs for the TI 99 family of home computers on\r\nmodern computer systems.\r\n\r\nAs of this release, the cross-development tools comprise\r\n\r\n * `xas99`, a TMS9900 cross-assembler,\r\n * `xga99`, a GPL cross-assembler,\r\n * `xbas99`, a TI BASIC and TI Extended BASIC lister and encoder,\r\n * `xdm99`, a disk manager for sector-based TI disk images,\r\n * `xhm99`, a manager for HFE images used by HxC floppy emulators, and\r\n * `xvm99`, a volume manager for nanoPEB/CF7+ Compact Flash cards.\r\n\r\nAll programs are written in Python and thus run on any platform that Python\r\nsupports, including Linux, Windows, and OS X.\r\n\r\nAdditionally, xdt99 provides TI-specific editor support for some freely\r\navailable cross-platform development environments:\r\n\r\n * `xdt99-mode`, a major mode for the GNU Emacs text editor, and\r\n * `xdt99 IDEA`, a plugin for the IntelliJ IDEA development environment.\r\n\r\nThe plugins offer syntax highlighting, navigation, and semantic renaming for\r\nassembly and TI Extended BASIC programs in addition to environment-specific\r\nfunctionality.\r\n\r\nThe major design goals of xdt99 and differentiators to similarly spirited\r\nprojects such as the [TI Image Tool][6] or the [Winasm99 assembler][7] are\r\n\r\n * a comprehensive and consistent developer experience,\r\n * a flexible and powerful command-line interface, and\r\n * cross-platform availability.\r\n\r\nFuture developments will focus on further simplifying typical development tasks\r\nsuch as data conversion and program generation.\r\n\r\nxdt99 is released under the GNU GPLv2.  All [sources][2] are available on\r\nGitHub.  TI developers may also download the latest [binary release][3] of\r\nxdt99.\r\n\r\nThe [xdt99 homepage][1] always hosts the latest version of this document.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nDownload the latest [binary release][3] from GitHub (recommended) or clone the\r\n[xdt99 repository][2].  Please note that the big download buttons on top of the\r\nxdt99 homepage will include the entire repository; this is probably *not* what\r\nyou want.\r\n\r\nYou will also need a working copy of [Python 2.x][5] installed on your computer.\r\n`xdt99` has been developed using Python 2.7, but other versions should work as\r\nwell.  Note, however, that compatibility with Python 3 has been postponed to a\r\nlater release for now.\r\n\r\nBoth cross-assemblers and the disk manager are self-contained Python programs\r\nthat may be used independently of each other.  The volume manager and the HFE\r\nmanager depends on the disk manager and cannot be used without it.  For\r\ninstallation, simply place the files `xas99.py`, `xga99.py`, `xbas99.py`,\r\n`xdm99.py`, `xhm99.py`, and `xvm99.py` somewhere in your `$PATH` or where your\r\ncommand-line interpreter will find them.  Windows users will find additional\r\ninformation about installation and how to get started in the\r\n[Windows Tutorial][6].\r\n\r\nThe `ide/` directory contains the editor plugins for GNU Emacs and IntelliJ\r\nIDEA.  Please refer to the `EDITORS.md` file for further information about\r\neditor support.\r\n\r\nThe `lib/` directory contains the Jumpstart cartridge and some supporting\r\nfunctions that you may use in your TI programs.\r\n\r\nThe `example/` directory of the binary distribution contains some sample files\r\nthat are referenced throughout this manual.\r\n\r\n\r\nxas99 Cross-Assembler\r\n---------------------\r\n\r\nThe `xas99` cross-assembler translates TMS9900 assembly code into executable\r\nprograms for the TI 99 home computer equipped with the Editor/Assembler module\r\nor the Mini Memory module.\r\n\r\nInvoking `xas99` in standard mode will assemble a TMS9900 assembly source code\r\nfile into an object code file that may be loaded using the Editor/Assembler\r\nmodule option 3.\r\n\r\n    $ xas99.py -R ashello.a99\r\n\r\n`xas99` also generates program image files for the Editor/Assembler module\r\noption 5 or RPK cartridge files suitable for the MESS emulator:\r\n\r\n    $ xas99.py -R -i ashello.a99\r\n    $ xas99.py -R -c ashello.a99\r\n\r\nAll existing assembly code for the TI 99, e.g., the Tombstone City source code\r\nshipped with the Editor/Assembler module, should cross-assemble using `xas99`\r\nwithout requiring any source code modifications.\r\n\r\nThe object code generated by `xas99` is identical to uncompressed object code\r\nproduced by the original TI Editor/Assembler package.  This includes all of its\r\nquirks, such as shortened object code lines or excessive address specifications,\r\nbut hopefully none of its bugs, such as invalid tags for certain `DEF`s.\r\n\r\nFor a detailed step-by-step example on how to cross-assemble and run an assembly\r\nprogram using the xdt99 tools and the MESS emulator please refer to the Example\r\nUsage section below.\r\n\r\nFinally, please note that even though the object code format of the TI 99 home\r\ncomputer shares many similarities with that of other TMS9900-based systems, most\r\nnotably the TI 990 mini computers, `xas99` currently targets the TI 99\r\nexclusively.\r\n\r\n\r\n### Assembling Source Code\r\n\r\nThe `xas99` cross-assembler reads an assembly source code file and generates an\r\nuncompressed object code file that is suitable for the original TI 99\r\nEditor/Assembler loader.\r\n\r\n    $ xas99.py -R ashello.a99\r\n    $ xas99.py -R ashello.a99 -o HELLO-O\r\n\r\nThe output parameter `-o` may be used to override the default output filename.\r\n\r\nThe assembly options `-R` (register symbols), `-S` (symbol table), `-L`\r\n(listing), and `-C` (compressed object code) correspond to the respective\r\noptions of the TI Editor/Assembler module.  You will need to add `-R` if you\r\nprefer to write `MOV R0,*R1+` etc. instead of `MOV 0,*1+` in your source code.\r\n\r\nCurrently, only options `-R`, `-C`, and `-L` are supported; option `-S` is\r\nsilently ignored.\r\n\r\n`xas99` will report any errors to `stderr` during assembly.  Note that the\r\ngenerated object code may differ from the code generated by the Editor/Assembler\r\npackage in the case of errors.  `xas99` is slightly more permissive than the\r\nEditor/Assembler, but it should be able to assemble any source that the\r\nEditor/Assembler package can assemble.\r\n\r\n\r\n### Creating Program Images\r\n\r\nThe image parameter `-i` tells `xas99` to generate image files that can be\r\nloaded using Editor/Assembler option 5.\r\n\r\n    $ xas99.py -R -i ashello.a99\r\n\r\nImages larger than 8 KB are split automatically into multiple files, using the\r\nfilename convention of the Editor/Assembler module.\r\n\r\nThe `-i` parameter simulates the `SAVE` utility program shipped with the\r\nEditor/Assembler package and honors the symbols `SFIRST` and `SLAST` to generate\r\na single image for the entire memory area spanned by those two addresses.  The\r\nimage is automatically chunked into 8 KB files for the E/A loader.\r\n\r\nAlternatively, if either symbol is missing, `xas99` will generate separate image\r\nfiles for each program segment defined in the assembly source code.  For\r\nexample, the assembly of source file\r\n\r\n         AORG >A000\r\n    L1   B @L2\r\n         AORG >B000\r\n    L2   B @L1\r\n\r\nwill yield two images files of 10 bytes each instead of a single file of 4 KB.\r\n\r\nNote that the E/A loader for program files happily loads non-contiguous image\r\nfiles for individual program segments even though original `SAVE` utility does\r\nnot support this feature.\r\n\r\nFor further control about the memory regions to save see the `SAVE` directive\r\nbelow.\r\n\r\nThe optional `--base` argument can be used to define the base address for\r\nrelocatable code.  If no base address is given, default address `>A000` is used.\r\n\r\nAll the usual restrictions for program images apply.  In particular, the first\r\nword of the first image file must be an executable instruction.\r\n\r\n\r\n### Creating MESS Cartridges\r\n\r\nThe cartridge parameter `-c` tells `xas99` to create an RPK cartridge file that\r\ncan be used with the MESS emulator.\r\n\r\n    $ xas99.py -R -c ascart.a99 -n \"HELLO WORLD\"\r\n\r\nThe optional name parameter `-n` overrides the default name of the program that\r\nshows up in the TI 99 menu selection screen.\r\n\r\nThe resulting RPK archive is a ZIP file containing the actual program code plus\r\nvarious information for the MESS emulator on how to execute the program.\r\nTypically, RPK files are passed as arguments to the MESS executable, or they may\r\nbe mounted while running MESS using the emulator on-screen menu.\r\n\r\n    $ mess64 ti99_4ae -cart ascart.rpk\r\n\r\nWhen the `-c` option is given, `xas99` will automatically generate suitable GPL\r\nheader information and relocate the program to address `>6030`, but it will not\r\nprocess the source code any further.  In particular, the usual restrictions on\r\nusing VDP memory access routines apply.\r\n\r\nNote that cartridge files cannot be generated from split image files.\r\n\r\n\r\n### Creating Raw Binaries\r\n\r\nImage files for the E/A loader option 5 contain the actual program code that is\r\nloaded verbatim into memory.  They also contain a small amount of metadata that\r\ninstructs the loader how many files to load and where to store the data.\r\n\r\nThe binary parameter `-b` tells `xas99` to generate raw binary files without\r\nmetadata that are suitable for burning EPROMs or supplying other devices.\r\n\r\n    $ xas99.py -R -b ascart.a99 --base 0x6000\r\n\r\nThe assembler will generate one binary file per code segment.  For further\r\ncontrol, the `SAVE` directive may be used (see below).\r\n\r\nThe optional `--base` argument sets the base address for relocatable segments;\r\nif no argument is given, `>0000` is used.\r\n\r\n\r\n### Jumpstarting\r\n\r\nTo make the code, assemble, run cycle as fast as possible, `xas99` can\r\ngenerate so-called \"jumpstart disks\" that may be loaded and executed by the\r\nJumpstart cartridge included with xdt99.\r\n\r\n    $ xas99.py --jumpstart -R ascart.asm\r\n    $ mess64 ti99_4ae -cart lib/jumpstart.rpk -flop1 ascart.dsk\r\n\r\nThe example above shows the invocation for MESS, but any emulator should\r\nwork.  Obviously, the emulator must be setup with 32K memory expansion and\r\nat least one floppy disk drive.\r\n\r\nSelecting the Jumpstart option in the TI 99 main menu will load the jumpstarted\r\nprogram from any inserted disk and run it.  Thus, selecting either option 3\r\nor 5 in the Editor/Assembler module and manually entering the program filename\r\nis no longer required.\r\n\r\nCurrently, jumpstarted programs may consist of up to 8 segments and must fit\r\nentirely into memory areas `>2000`-`>3EFF` and `>A000`-`>FFFF`.\r\n\r\n\r\n### Other Formats\r\n\r\nFor relocatable code not larger than around 24 KB, `xas99` can generate an\r\nExtended BASIC program that invisibly contains the generated code within:\r\n\r\n    $ xas99.py --embed-xb ashello.a99 \r\n\r\nThe resulting program is a regular Extended BASIC program in so-called \"long\"\r\nformat that will execute the assembly code when run:\r\n\r\n    >OLD DSK1.ASHELLO\r\n    >RUN\r\n\r\nThus, the `--embed-xb` options allows for the creation of assembly programs that\r\ndo require the Editor/Assembler module for execution.\r\n\r\nThe generated Extended BASIC program will have only one visible line:\r\n\r\n    1 CALL INIT :: CALL LOAD(163\r\n    76,88,89,90,90,89,32,255,228\r\n    ):: CALL LOAD(8196,63,248)::\r\n     CALL LINK(\"XYZZY\")\r\n\r\nBut be careful: editing the generated program is likely to corrupt the embedded\r\nassembly code!\r\n\r\n\r\n### Creating List Files\r\n\r\nThe `-L` option instructs `xas99` to generate a list file for the assembled\r\nsource code:\r\n\r\n    $ xas99.py -R ashello.a99 -L ashello.lst\r\n\r\nThe list file is useful for inferring the relative or absolute memory addresses\r\nof source code lines or the effective values of expressions.\r\n \r\nThe format of the list file is almost identical to that of the original\r\nEditor/Assembler module.  The most prominent difference is the listing of\r\nthe `BYTE` directive, where individual byte values are grouped into words.\r\n\r\n\r\n### TMS9900 Assembly Support\r\n\r\nThe `xas99` is a complete TMS9900 assembler supporting all documented TMS9900\r\nopcodes.  TMS9995 opcodes such as `MPYS` and `DIVS` are currently not supported\r\nbut may be added in a future release.\r\n\r\n`xas99` understands all assembler directives described in the Editor/Assembler\r\nmanual that are supported by both TI 99 assembler and loader, i.e.,\r\n\r\n    DEF REF EQU DATA BYTE TEXT BSS BES AORG RORG DORG EVEN\r\n    IDT DXOP COPY END\r\n\r\nNote that the `DORG` directive *is* supported, even though the TI assembler does\r\nnot do so.\r\n\r\nThe following directives are not supported by the TI 99 loader and are thus\r\nsilently ignored by `xas99`:\r\n\r\n    PSEG PEND CSEG CEND DSEG DEND LOAD SREF\r\n\r\nListing generation is currently not supported, so directives\r\n\r\n    LIST UNL PAGE TITL\r\n\r\nare also ignored.\r\n\r\n\r\n#### Source Code Organization\r\n\r\nThe `COPY` directive is used to break large assembly sources into individual\r\nfiles.\r\n\r\n`xas99` will search the current source directory for appropriately named source\r\nfiles.  For example, assembling\r\n\r\n    $ xas99.py src/file1.a99\r\n\r\nwhere `file1.a99` contains the instruction `COPY \"DSK1.FILE2\"` will search for\r\ninclude files\r\n\r\n    src/FILE2\r\n    src/FILE2.A99\r\n    src/FILE2.ASM\r\n    src/FILE2.S\r\n\r\nand its corresponding lower-case variants.\r\n\r\nAdditional search paths may be specified with the `-I` option as a\r\ncomma-seperated list, e.g.,\r\n\r\n    $ xas99.by -I lib/,disk2/ ashello.asm\r\n\r\n`COPY` also supports native file paths, e.g., `COPY \"ti/src/file2.a99\"`.\r\n\r\n`xas99` also provides a new directive `BCOPY` that includes an external binary\r\nfile as a sequence of `BYTE`s.  Please refer to the section about *xdt99\r\nExtensions* for further information. \r\n\r\n\r\n### `xdt99` Extensions\r\n\r\nThe `xas99` cross-assembler offers various \"modern\" extensions to the original\r\nTI Assembler to improve the developer experience for writing assembly programs.\r\nAll extensions are backwards compatible in virtually all situations of practical\r\nrelevance so that any existing source code should compile as-is.\r\n\r\nComments may be included anywhere in the source code by prepending them with a\r\nsemicolon `;`.  A `;` character inside a text literal `'...'` or filename\r\n`\"...\"` does *not* introduce a comment.\r\n\r\nSource code is processed case insensitively so that all labels, expressions, and\r\ninstructions may be written in upper case, lower case, or any mixture.  Text\r\nliterals are still case sensitive, though.\r\n\r\n    label1 byte >A,>b\r\n    LABEL2 TEXT 'Hello World'\r\n    Label3 mov Label1(R1),Label2(r2)\r\n    \r\nLabels may be of arbitrary length and may contain arbitrary characters except\r\nfor whitespace and operators such as `+`, `*`, `(`, `$`, etc.  An optional\r\ncolon `:` may be appended to the label name.  The colon is not part of the\r\nname, but logically continues the current line to the next:  \r\n\r\n    my_label_1:\r\n        equ 1         ; assigns 1 to my_label_1\r\n    my_label_2:\r\n        aorg >a000    ; assigns >a000 to my_label_2\r\n    my_label_3        ; assigns >a000 to my_label_3  \\  standard E/A\r\n        aorg >b000    ; no label to assign >b000 to  /  behavior\r\n\r\nLocal labels simplify the implementation of small loops.  A local label is\r\nintroduced by an exclamation mark `!` and an optional name.  Thus, the simplest\r\nlocal label is just a single `!`.  Local labels need not be unique within the\r\nprogram.\r\n  \r\nReferences to local labels are resolved relative to the current position.  By\r\ndefault, matching labels are searched after the current position.  References\r\nprefixed with a unary minus sign `-` are searched before the current position.\r\n\r\n    clear_data:\r\n        li   r0, >a000\r\n        li   r2, >100\r\n    !   clr  *r0+         ; make jump target without potential name conflicts\r\n        dec  r2\r\n        jne  -!           ; jump to target two lines above\r\n        rt\r\n\r\nDoubling, tripling, ... the number of `!`s before a reference refers to the\r\nsecond, third, ... match of the local label relative to the current position: \r\n\r\n    !   dec  r1              <-+\r\n        jeq  !     --+         |\r\n        inc  r2      |         |\r\n        jne  !!      |  --+    |\r\n        jmp  -!      |    |  --|\r\n    !   dec  r2    <-+    |    |\r\n        jmp  -!!          |  --|\r\n    !   inc  r1         <-+    |\r\n        jmp  -!!!            --+\r\n    !   rt        \r\n            \r\nNote that labels `label` and `!label` are entirely different and can be used\r\nwithout conflict in the same program.\r\n\r\nThe use of whitespace has been relaxed.  Single spaces may be used judiciously\r\nwithin the operand field to increase the legibility of expressions.  Two or more\r\nspaces as well as tabs introduce the comment field.\r\n\r\n    label  data addr + len - 1  comment\r\n           movb @addr + 2(r1), *r2+ ; comment\r\n\r\n(*Technical note*: It is not possible to detect the beginning of the comment\r\nfield based on the current instruction, as the example `LABEL EQU 1 * 2` shows.\r\nThe original TI Assembler parses `* 2` as comment, even though `1 * 2` is a\r\nvalid `EQU` expression.)\r\n\r\nThe extended expression syntax supports parentheses `(`, `)`, the modulo\r\noperator `%`, and binary operators bit-and `&`, bit-or `|`, bit-xor `^`, and\r\nbit-not `~` as well as binary literals introduced by `:`.\r\n\r\n    area    equ (xmax + 1) * (ymax + 1)\r\n    addr2   equ addr1 | >A000 & ~>001F\r\n    padding bss size % 8\r\n    binval  equ :01011010\r\n\r\nIt is important to note that all operators have the *same precedence*, i.e., an\r\nexpression such as `1 + 2 * 3 - 4 & 5` evaluates as `(((1 + 2) * 3) - 4) & 5`.\r\nThis may sound annoying, but changing the established order of evaluation would\r\nbreak the compatibility of `xas99` for existing sources.  To adjust the order of\r\nevaluation, parentheses can be used: `1 + (2 * 3) - (4 & 5)`.\r\n\r\nA source code preprocessor allows for conditional assembly based on well-defined\r\nconditional expressions.  The preprocessor commands `.ifdef` and `.ifndef` check\r\nif a given symbol is defined or not.\r\n\r\n           .ifdef lang_de\r\n    msg    text 'Hallo Welt'\r\n           .else\r\n    msg    text 'Hello World'\r\n           .endif\r\n\r\nThe commands `.ifeq`, `.ifne`, `.ifgt`, and `.ifge` test if two arguments are\r\nequal, not equal, greater than, or greater than or equal, resp.  If the second\r\nargument is missing, the first argument is compared against value `0`.\r\n\r\nIn addition to symbols defined by labels, `xas99` also sets exactly one of\r\n`_xas99_image`, `_xas99_cart`, `_xas99_obj`, `_xas99_xb`, or `_xas99_js`,\r\ndepending on the assembly command `-i`, `-c`, ... used.\r\n\r\nAdditional symbols may be supplied on the command line.\r\n\r\n    $ xas99.py ashello.a99 -D symbol1 symbol2=2\r\n\r\nIf no value is given, the symbol is set to value `1`.\r\n\r\nConditional assembly preprocessor commands may be nested.  Valid conditional\r\nexpressions and their rules of evaluation correspond to those of the `EQU`\r\ndirective.\r\n\r\n`xas99` supports macros.  The `.defm` preprocessor command introduces a new\r\nmacro.  The `.endm` command concludes the macro definition.  Inside the macro\r\nbody the macro parameters `#1`, `#2`, ... refer to the actual arguments that\r\nare supplied when instantiating the macro:\r\n\r\n    * fill top <#1> rows with char <#2>\r\n        .defm fill\r\n        li   r0, >0040\r\n        li   r1, #1\r\n        li   r2, #2 * 32\r\n        movb @vdpwa\r\n        swpb r0\r\n        movb @vdpwa\r\n    !   movb r1, @vdpwd\r\n        dec  r2\r\n        jne  -!\r\n        .endm\r\n\r\nMacros are used like preprocessor commands, with any arguments separated\r\nby commas:\r\n\r\n        .fill 10, '* '\r\n\r\nNote that macro parameters are resolved by textual replacement.  Thus,\r\nwhen instantiating \r\n\r\n        li   r0, 2 * #1\r\n\r\ninside some macro body with argument `1 + 2`, the resulting code will assign\r\nthe value 4 instead of 6 to `R0`.\r\n\r\nLabels are allowed inside macro definitions.  To avoid duplicate symbols, all\r\nlabels should be local.\r\n\r\nMacro definitions cannot be nested.  Macro uses may be nested, but\r\ninstantiations must not be circular.\r\n\r\nPreprocessor commands are always executed, even inside inactive `#ifdef` ...\r\n`#endif` blocks.  The correct way to define environment-dependent macros is\r\nthus\r\n\r\n    .defm mymacro\r\n    .ifdef symbol\r\n    clr r0\r\n    .else\r\n    clr r1\r\n    .endif\r\n    .endm\r\n\r\ninstead of the other way around.\r\n\r\n`xas99` also provides a new directive `BCOPY` that includes an external binary\r\nfile as a sequence of `BYTE`s.  For example, if `sprite.raw` is a raw data file\r\ncontaining some sprite pattern\r\n\r\n    $ hexdump -C sprite.raw\r\n    00000000  18 3c 7e ff ff 7e 3c 18                           |.<~..~<.|\r\n\r\nthen including this file with `BCOPY`\r\n\r\n    SPRITE  BCOPY \"sprite.raw\"\r\n\r\nis equivalent to the conventional assembly statement sequence\r\n\r\n    SPRITE  BYTE >18,>3C,>7E,>FF,>FF,>7E,>3C,>18\r\n\r\nThe extended `AORG` directive allows for an optional second argument that\r\nspecifies the memory bank for the following code segment.\r\n\r\n    * ASBANK.A99\r\n          AORG >6000,0\r\n    FUNC1 CLR R0\r\n          ...\r\n          AORG >6000,1\r\n    FUNC2 LI  R1,>1234\r\n          ...\r\n\r\nGenerating binary files with the `-b` command stores banked segments in\r\nseparate files, e.g.,\r\n\r\n    $ xas99.py -b asbank.a99\r\n    $ ls\r\n    asbank.a99  asbank_6000_b0.bin  asbank_6000_b1.bin\r\n\r\n`xas99` warns about illegal cross-bank accesses, but it cannot guarantee that\r\nthe correct bank is always active.\r\n\r\n          AORG >6000,0\r\n    L1    B    @L3      ; OK\r\n          B    @L2      ; error: different bank\r\n\r\n          AORG >6000,1\r\n    L2    B    @L3      ; OK\r\n          B    @L1      ; error: different bank\r\n\r\n          AORG >A000\r\n    L3    B    @L1      ; OK, needs correct bank\r\n          B    @L2      ; OK, needs correct bank\r\n\r\nIn this example, the `B` instructions in segment `A000` will both branch to\r\n`L1` or `L2`, depending on which bank is active.\r\n\r\nThe new `XORG` directive sets the location counter to a new address but does\r\nnot change the actual placement of the subsequent code segment.\r\n\r\n          AORG >6000\r\n    L1    DATA 0\r\n          MOV  @L1,@L2      ; moves >6000 to >8380\r\n          BL   @FUNC        ; branches to >8382\r\n\r\n    A1    XORG >8380\r\n    A2\r\n    L2    DATA 0\r\n    FUNC  A    @L2,@L1      ; adds >8380 to >6000\r\n          RT\r\n    A3\r\n\r\nThe list file for this program shows that the code of `FUNC` is placed within\r\nthe `>6000` segment:\r\n\r\n    0001                      AORG >6000\r\n    0002 6000 0000     L1     DATA 0\r\n    0003 6002 C820  54        MOV  @L1,@L2      ; moves >6000 to >8380\r\n         6004 6000\r\n         6006 8380\r\n    0004 6008 06A0  32        BL   @FUNC        ; branches to >8382\r\n         600A 8382\r\n    0005\r\n    0006               A1     XORG >8380\r\n    0007               A2\r\n    0008 600C 0000     L2     DATA 0\r\n    0009 600E A820  54 FUNC   A    @L2,@L1      ; adds >8380 to >6000\r\n         6010 8380\r\n         6012 6000\r\n    0010 6014 045B  20        RT\r\n    0011               A3\r\n\r\n`XORG` is useful for assembling code blocks that will be moved to a different\r\nmemory location, e.g., scratch pad RAM, before execution.\r\n\r\n    * MOVE FUNCTION TO SCRATCH PAD RAM\r\n    INIT  LI   R0,A1        ; source address of function\r\n          LI   R1,A2        ; target address of function\r\n          LI   R2,A3-A2     ; length of function to copy\r\n          BL   @COPY        ; fictious RAM to RAM copy routine\r\n\r\nNote that `xas99` cannot place `XORG` code directly into the indented target\r\nlocation; instead, all such blocks need to be copied manually in your program.\r\nFor this, `XORG` assigns the real placement address instead of the location\r\ncounter to its label.  Depending on the previous segment this address may be\r\nrelocatable or not.\r\n\r\nThe `XORG` directive can be used for all `xas99` output formats and is\r\ncompatible with both E/A option 3 and E/A option 5.\r\n\r\nThe `SAVE` directive controls the output format for the image `-i` and raw\r\nbinary `-b` output formats.\r\n\r\n          SAVE >6000,>7000   ; generate single image for >6000->6FFF\r\n\r\n          AORG >6000\r\n    MAIN  LIMI 0\r\n          ...\r\n          AORG >6100\r\n    SUBR  CLR  R0\r\n          ...\r\n\r\nFor each `SAVE`, a binary file containing the values of the specified memory\r\nregion will be generated.  If the region contains banked memory, a separate file\r\nfor each bank is written.  Empty regions, i.e., regions in which no actual value\r\nis placed, are skipped.\r\n\r\nIf no `SAVE` directives are provided, the `-b` command will place each segment\r\nin its own output file, but merges adjacent segments into one file.  The `-i`\r\ncommand will save the region between symbols `SFIRST` and `SLAST`, if present;\r\notherwise, it generates images for each segment individually.\r\n\r\nThe use of `SAVE` is recommended to reduce the number of generated files if\r\n`XORG` is employed.\r\n\r\n`xas99` supports the F18A GPU instruction set.\r\n\r\n    CALL <gas>\r\n    RET\r\n    PUSH <gas>\r\n    POP  <gad>\r\n    SLC  <wa>, <count>  \r\n    PIC  <gas>, <gad>\r\n\r\nNote that `PIC` is not an immediate instruction, so its arguments need to be\r\nconstructed separately by hand.\r\n\r\nThe `SPI` family of instructions is not supported; please use their equivalents\r\n`CKON`, ... instead.\r\n\r\n#### Compatibility\r\n\r\nThe strictness option `-s` disables all `xas99`-specific extensions to improve\r\nbackwards compatibility for old sources:\r\n\r\n    $ xas99.py -s ashello.a99\r\n\r\nStrictness is required, for example, to compile the *Tombstone City* sample\r\nsource code shipped with the original TI Editor/Assembler module.  Some of the\r\ncomments do not adher to the two-space separator rule of the relaxed xdt99\r\nwhitespace mode:\r\n\r\n    R5LB   EQU SUBWS+11 * REGISTER 5 LOW BYTE.\r\n    ***** Unknown symbol: REGISTER 5 LOW BYTE.\r\n\r\nFinally, note that case insensitivity cannot be disabled at the moment.\r\n\r\n\r\nxga99 GPL Cross-Assembler\r\n-------------------------\r\n\r\nThe `xga99` GPL cross-assembler translates programs written in TI's proprietary\r\nGraphics Programming Language into byte code that can be interpreted by the TI\r\n99 home computer.\r\n\r\nInvoking `xga99` in standard mode will assemble a GPL source code file into\r\nplain GPL byte code that may be placed in a physical or emulated GROM or GRAM\r\ndevice.\r\n\r\n    $ xga99.py gahello.gpl\r\n    $ xga99.py gahello.gpl -o gahello.bin\r\n\r\nThe output parameter `-o` may be used to override the default output filename,\r\nwhich uses extension `.gbc` (for \"GPL byte code\").\r\n\r\nThe image parameter `-i` tells `xga99` to generate suitable GPL header data for\r\nthe program so that the GPL byte code interpreter built into the TI 99 can\r\nexecute the image file.\r\n\r\n    $ xga99.py -i gahello.gpl\r\n\r\n`xga99` will check if there is enough space at the beginning of the image file\r\nfor inserting GPL header data.  You may have to adjust (or remove) any `AORG`\r\ndirectives if there is not enough space available.\r\n\r\nProgram execution will start at the symbol provided with the `END` directive, or\r\nthe `START` symbol, or the first byte of the byte code, in this order.\r\n\r\nThe cartridge parameter `-c` relocates the GPL program to the cartridge GROM\r\narea, generates GPL header data, and packages the byte code image into a\r\ncartridge file suitable for the MESS emulator.\r\n\r\n    $ xga99.py -c gahello.gpl\r\n\r\nThe resulting `.rpk` file may be executed as-is by the MESS emulator:\r\n\r\n    $ mess64 ti99_4ae -cart gahello.rpk\r\n\r\nThe optional name parameter `-n` overrides the default name of the program that\r\nshows up in the TI 99 menu selection screen.\r\n\r\n    $ xga99.py -c gahello.gpl -n \"HELLO GPL WORLD\"\r\n\r\nAs the Graphics Programming Language was never intended for public release,\r\nexisting native tools for assembling GPL source code differ substantially in the\r\nlanguage syntax they support.  `xga99` adopts a variation of the Ryte Data GPL\r\nAssembler syntax as its native format, but other syntax styles may be chosen\r\nwith the syntax parameter `-s`.\r\n\r\n    $ xga99.py sdemo.gpl -s rag\r\n\r\nCurrently supported syntax styles are `xdt99` for the `xga99` native format,\r\n`rag` for the Ryte Data and R.A.G. GPL assemblers, and `mizapf` for the TI Image\r\nTool GPL disassembler.  Note that the original GPL syntax described in TI's *GPL\r\nProgrammer's Guide* was considered too arcane for inclusion in `xga99`.\r\n\r\nThe native `xdt99` syntax style is more \"modern\" in that it supports lower case\r\nsources and relaxes the use of whitespace.  For details, please refer to the\r\nrespective section of the `xas99` manual.\r\n\r\n\r\n### GPL Instructions\r\n\r\n`xga99` supports all GPL mnemonics described in the *GPL Programmer's Guide*.\r\nAs is common practice, however, the operand order for the shift instructions\r\n`SLL` etc. has been reversed from `Gd, Gs` to `Gs, Gd`.\r\n\r\nInstruction operands use the well-established prefix notation to address CPU\r\nRAM, VDP RAM, and GROM/GRAM, respectively:\r\n\r\n    @<cpuram addr>  ....................  CPU RAM direct\r\n    *<cpuram addr>  ....................  CPU RAM indirect\r\n    V@<vdpram addr>  ...................  VDP RAM direct\r\n    V*<cpuram addr>  ...................  VDP RAM indirect\r\n    @<cpuram addr>(@<cpuram addr>)  ....  CPU RAM indexed\r\n    V@<vdpram addr>(@<cpuram addr>)  ...  VDP RAM indexed\r\n    G@<grom addr>  .....................  GROM/GRAM direct   (MOVE only)\r\n    G@<grom addr>(@<cpuram addr>)  .....  GROM/GRAM indexed  (MOVE only)\r\n    #<vdp reg>  ........................  VDP register       (MOVE only)\r\n\r\nNote that symbols do not imply a certain memory type, so references to GROM\r\naddresses in `MOVE` instructions still need to prepend `G@` to the symbol name:\r\n\r\n    T1 TEXT 'HELLO'\r\n    L1 MOVE 5,G@T1,V@100\r\n\r\nFor branch and call instructions, prefixing addresses by `G@` is optional, as\r\nbranch targets always reside in GROM/GRAM:\r\n\r\n    B L1\r\n    B G@L1\r\n\r\nInstruction operands may be complex expressions of symbols and literals.\r\nLiterals may be decimal numbers, hexadecimal numbers prefixed by `>`, binary\r\nnumbers prefixed by `:`, and text literals enclosed in single quotes `'`.\r\n\r\n    BYTE 10, >10, :10, '1'\r\n\r\nExpressions are built using arithmeical operators `+`, `-`, `*`, `/`, `%`, and\r\n`**` and bit operators `&`, `|`, `^`, and `~`.  Expressions are evaluated\r\nleft-to-right with equal operator precedence; parentheses may be used to change\r\nthe order of evaluation.  For further details please refer to the `xas99`\r\nsection on expressions.\r\n\r\nBy default, `xga99` uses the following mnemonics for the `FMT` sub-language, but\r\nother syntax styles are available with the `-s` option:\r\n\r\n    HTEXT/VTEXT <text>\r\n    HCHAR/VCHAR <len>, <char>\r\n    HMOVE <len>, <gs>\r\n    ROW/COL <n>\r\n    ROW+/COL+ <n>\r\n    BIAS <n>/<gs>\r\n    FOR <n> ... FEND [<label>]\r\n\r\nNote that unlike the Ryte Data GPL Assembler, `xga99` also supports the optional\r\naddress label for the `FEND` instruction.\r\n\r\n\r\n### GPL Directives\r\n\r\nThe `xga99` GPL assembler supports the following directives:\r\n\r\n    GROM AORG EQU DATA BYTE TEXT STRI BSS TITLE COPY\r\n\r\nDirectives affecting listing generation are currently ignored:\r\n\r\n    PAGE LIST UNL LISTM UNLM\r\n\r\nMost `xga99` directives work very similar to their `xas99` counterparts.\r\n\r\nThe `BYTE` and `DATA` directives insert bytes and words into the program,\r\nrespectively, irrespective of the size of their arguments.\r\n\r\n    LABEL BYTE 1,>02,:11011010,'@',>100\r\n          DATA 1,>1000,'A'\r\n\r\nThe `TEXT` directive generates a sequence of bytes from a text literal or an\r\nextended hexadecimal literal.\r\n\r\n    LABEL TEXT 'Groovin'' With GPL'\r\n          TEXT >183C7EFFE7C381\r\n\r\nNote that the second instruction is equivalent to `BYTE >18,>3C,>7E,...`.\r\n\r\nThe `STRI` directive works similar to the `TEXT` directive but prepends the\r\ngenerated byte sequence with a length byte.\r\n\r\nThe `GROM` directive sets the GROM base address for the code that follows.\r\nCurrently only one `GROM` directive per source file is supported.  Note that the\r\n`GROM` directive expects the actual GROM address, e.g., `>6000`, instead of an\r\ninteger number such as `3`.\r\n\r\nThe `AORG` directive is used to place individual code segments at specific\r\naddresses within the given GROM.  The address argument is thus relative to the\r\nGROM base address given by `GROM`.\r\n\r\nInstead of using the `GROM` and `AORG` directives in the source file the\r\nlocation of the final GPL byte code image may also be specified by command-line\r\nparameters `-G` and `-A`, respectively.  Note that cartridge parameter `-c`\r\nimplies `-G 0x6000` and `-A 0x30`.\r\n\r\n\r\n### `xdt99` Extensions\r\n\r\nThe `xga99` GPL cross-assembler offers various \"modern\" extensions to the\r\noriginal TI GPL specification to improve the developer experience for writing\r\nGPL programs.  All extensions are backwards compatible in virtually all\r\nsituations of practical relevance so that any existing source code should\r\ncompile as-is.\r\n\r\nThe source code preprocessor supports conditional assembly `.ifdef` and macros\r\n`.defm`.  For a description of both features please refer to the respective\r\nsection in the `xas99` manual.\r\n\r\nNote, however, that GPL macros use macro parameters `$1`, `$2`, ... instead\r\nof `#1`, `#2`, ..., as the latter are used to denote VDP registers in GPL.\r\n\r\nThe predefined symbols set by `xga99` are `_xga99_image`, `_xga99_cart`, or\r\n`_xga99_gbc`, depending on the assembly command `-i`, `-c`, ... used.\r\n\r\n\r\nxbas99 TI BASIC and TI Extended BASIC Tool\r\n------------------------------------------\r\n\r\n`xbas99` is a command-line tool for converting TI BASIC and TI Extended BASIC\r\nprograms from source format to internal format, and vice versa.  For brevity, we\r\nwill refer to both TI BASIC and TI Extended BASIC programs simply as BASIC\r\nprograms.\r\n\r\nPrograms in source format are plain text files that contain the BASIC statements\r\nthat a user would usually type in.  These kind of text files are usually not\r\nstored on real TI 99 home computer systems.\r\n\r\nPrograms in internal format are TI-specific files in `PROGRAM` format that are\r\ngenerated by the `SAVE` command and understood by the `OLD` and `RUN` commands.\r\n`xbas99` also supports programs created in so-called long format `INT/VAR 254`\r\nand in merge format `DIS/VAR 163`.\r\n\r\nTypical use cases for `xbas99` include the listing of programs stored in\r\ninternal format and the creation of program files for the BASIC interpreter from\r\na text file with BASIC statements.\r\n\r\nThe list command `-l` lists the statements of a BASIC program in internal format on\r\nthe screen.  Formatting is identical to the built-in BASIC `LIST` command modulo\r\nthe line wrapping.\r\n\r\n    $ xbas99.py -l bashello.bin\r\n    10 REM HELLO\r\n    20 INPUT \"YOUR NAME? \":NAME$\r\n    30 PRINT \"HELLO \";NAME$\r\n    40 END \r\n\r\nThe similar decode command `-d` saves the program listing to a file instead:\r\n\r\n    $ xbas99.py -d bashello.bin\r\n\r\n`xbas99` uses extensions `.bas` for BASIC programs in source format and `.bin`\r\nfor programs in internal format.  To override the default naming convention, the\r\n`-o` argument may be used:\r\n\r\n    $ xbas99.py -d bashello.bin -o sample_program.txt\r\n\r\nBASIC programs in long format are detected automatically.  To list programs in\r\nmerge format, simply add the merge option `--merge`.\r\n\r\n(Technical note: On Windows, you currently cannot use `xdm99` to extract BASIC\r\nprograms saved in merge format.  For some unknown reason merge programs are\r\nstored in `DIS/VAR` format even though they are binary data.  Windows will try\r\nto translate suspected end-of-line markers and thus garble the file contents.)\r\n\r\nThe create command `-c` encodes a list of BASIC statements into internal format\r\nso that the resulting file can be loaded and run by the BASIC interpreter on a\r\nTI 99:\r\n\r\n    $ xbas99.py -c bashello.bas\r\n\r\n`xbas99` assumes that the text file is stored in the native file format of the\r\nhost computer.  Each program line should be stored on a separate line, but the\r\njoin option `-j` may be used to automatically join split, i.e., word-wrapped,\r\nlines.\r\n\r\n    $ xbas99.py -c bashello.txt -j <line-delta>\r\n\r\nAny line that does not begin with a number or whose supposed line number is not\r\nbetween the previous line number and the previous line number plus `line-delta`\r\nis considered a continuation of the previous line.\r\n\r\nThe long option `--long` instructs `xbas99` to create the program in long\r\nformat.  Long programs are stored within the 32 KB memory expansion and may be\r\nlarger than conventional programs.  For petty technical reasons, the creation of\r\nprograms in merge format is currently not supported.\r\n\r\nThe protection option `--protect` will add list protection to the generated\r\nprogram.  Programs with list protection cannot be listed or edited by the BASIC\r\ninterpreter.  Note, however, that the list command of `xbas99` will /not/ honor\r\nthe protection flag.\r\n\r\nProgram files created by `xbas99` are raw `PROGRAM` files that may have to be\r\ntransferred to a disk image or converted to TIFILES format before they can be\r\nused by an emulator or transferred to a real TI 99.  The `xdm99` tool covers\r\nboth of these operations:\r\n\r\n    $ xdm99.py basic.dsk -a bashello.bin\r\n    $ xdm99.py -T bashello.bin\r\n\r\nAdvanced users of xdt99 may also combine the creation of the BASIC program file\r\nand the transfer to a disk image in one single step:\r\n\r\n    $ xbas99.py -c bashello.bas -o - | xdm99.py basic.dsk -a - -n HELLO\r\n\r\nAll tools in xdt99 follow the convention that the special filename `-` denotes\r\n`stdin` or `stdout`, respectively.  You can also pipe from `xdm99` into `xbas99`\r\nto list BASIC programs quickly that are stored on a disk image:\r\n\r\n    $ xdm99.py basic.dsk -p HELLO | xbas99.py -l - \r\n\r\nFinally, `xbas99` does not distinguish between TI BASIC and TI Extended BASIC\r\nprograms.  To create a TI BASIC program that does not rely on the TI Extended\r\nBASIC module simply do not use any of the advanced Extended BASIC features such\r\nas `::` or subprograms like `SPRITE`.\r\n\r\nAlso note that the tool will read and encode any text file that you supply, with\r\nonly minimal syntax checking.  In other words, the resulting program file should\r\nalways load with `OLD`, but it may not `RUN`.  A future version of `xbas99` may\r\ncontain more advanced checks to assist developers in creating new BASIC\r\nprograms.\r\n\r\n\r\nxdm99 Disk Manager\r\n------------------\r\n\r\n`xdm99` is a command-line tool for cataloging and manipulating sector-based TI\r\ndisk images used by most emulators, including MESS.  `xdm99` also supports the\r\nTIFiles file format that retains TI-specific meta data for files that originate\r\nfrom TI disk images.\r\n\r\n\r\n### Cataloging Disks\r\n\r\nThe default operation of `xdm99` when invoked without any options is to print\r\nthe file catalog of the disk image to `stdout`:\r\n\r\n    $ xdm99.py ed-asm.dsk\r\n    ED-ASSM   :     97 used  263 free   90 KB  1S/1D  40 TpS\r\n    ----------------------------------------------------------------------------\r\n    ASSM1         33  PROGRAM       8192 B\r\n    ASSM2         18  PROGRAM       4102 B\r\n    EDIT1         25  PROGRAM       5894 B\r\n    SAVE          13  DIS/FIX 80    3072 B   36 recs\r\n    SFIRST/O       3  DIS/FIX 80     512 B    5 recs\r\n    SLAST/O        3  DIS/FIX 80     512 B    4 recs\r\n\r\nThe top line shows the name of the disk, the number of used and free sectors as\r\nwell as the disk geometry.  For each file, the number of used sectors, the file\r\ntype, the file length, and the actual number of records is shown.  If present,\r\nthe file modification time is also shown.\r\n\r\n`xdm99` will warn about any inconsistencies it may find, e.g., blocks claimed by\r\nfiles but not allocated in the allocation map.  When assembling programs\r\nnatively these inconsistencies happen more frequently than one would assume.\r\nFiles affected by inconsistencies are flagged with `ERR` in the catalog.  You\r\ncan try the `-R` option to automatically repair disks with inconsistencies.\r\n\r\n\r\n### Extracting Files\r\n\r\nThe extract parameter `-e` extracts one or more files from a disk image to the\r\nlocal file system.\r\n\r\n    $ xdm99.py work.dsk -e HELLO-S CART-S\r\n\r\nThe local output filename is derived automatically from the TI filename but\r\nmay be overridden with the `-o` parameter if only one file is extracted.\r\n\r\n    $ xdm99.py work.dsk -e HELLO-S -o hello.a99\r\n\r\nTo print the contents of a file to `stdout`, the print parameter `-p` may also\r\nbe used:\r\n\r\n    $ xdm99.py work.dsk -p HELLO-S\r\n\r\nIn general, printing files only makes sense for files in DIS/FIX or DIS/VAR\r\nformat.  Following Unix conventions, `-p` is equivalent to combining parameters\r\n`-e` and `-o \"-\"`.\r\n\r\nFilenames given by `-e` may be glob patterns containing wildcards `*`\r\nand `?`.  This will extract all files matching the given pattern.\r\n\r\n    $ xdm99.py work.dsk -e \"HELLO-*\"\r\n\r\nNote that you may have to quote your glob pattern to prevent your\r\nshell from expanding the pattern prematurely.\r\n\r\nExtracting files will yield the file contents only.  In order to\r\nretain file meta data about file type and record length, use the\r\nTIFiles or v9t9 formats described below.\r\n\r\n\r\n### Manipulating Disks\r\n\r\nThe add parameter `-a` adds local files to the disk image.  `xdm99` will infer a\r\nsuitable TI filename from the local filename unless an explicit filename is\r\ngiven by the `-n` parameter.  If the file is not of type `PROGRAM`, the file\r\ntype must be given using the `-f` parameter.\r\n\r\n    $ xdm99.py work.dsk -a ashello.a99 -n HELLO-S -f DIS/VAR80\r\n\r\nThe syntax for `-f` is fairly permissible, e.g., `DIS/FIX 80`, `DISFIX80`, or\r\n`DF80` all work.\r\n\r\nWhen adding multiple files with the `-n` option, the last character of the\r\nspecified filename will be incremented by one for each subsequent file, e.g.,\r\n \r\n    $ xdm99.py work.dsk -a intro main appendix -n FILE\r\n\r\nwill add the files as `FILE`, `FILF`, and `FILG` to the disk image.\r\n\r\nThe rename parameter `-r` renames one or more files on the disk.\r\n\r\n    $ xdm99.py work.dsk -r HELLO-S:HELLO/S\r\n\r\nFor each file to rename, provide the old filename. followed by a colon `:`,\r\nfollowed by the new filename. \r\n\r\nThe delete parameter `-d` deletes one or more files on the disk.\r\n\r\n    $ xdm99.py work.dsk -d HELLO-I HELLO-O\r\n    $ xdm99.py work.dsk -d \"*-O\"\r\n\r\nNote that the current implementation of `xdm99` does not perform a \"secure\r\nerase\", i.e., parts of the file contents may remain hidden in the sectors of the\r\ndisk image.\r\n\r\nFile operations do not retain the overall sector structure of the disk.  In\r\nparticular, all files will be defragmented whenever files are added or deleted\r\nwith `-a` or `-d`, respectively, or when the disk is repaired with `-R`.  Simply\r\ncataloging the disk, however, will *not* modify the disk image.\r\n\r\nBy default, all modifying disk operations will change the disk image directly.\r\nTo create an independent copy of the original disk image with the changes\r\napplied, the `-o` parameter may be used.\r\n\r\n\r\n### Files in a Directory (FIAD)\r\n\r\nExtracting files from a TI disk image to the local file system will lose certain\r\nTI-specific file information, such as the file type or the record length.  In\r\norder to retain this meta information along with the file contents, the v9t9 and\r\nTIFiles formats were created.  The approach of storing TI files directly on the\r\nlocal file system instead of using a disk image is also known as \"files in a\r\ndirectory\" (FIAD).\r\n\r\n`xdm99` supports the TIFiles format and the v9t9 format for FIAD files by using\r\nthe `-t` and `-9` options, respectively.  To extract a file in either FIAD\r\nformat, simply add `-t` or `-9` to the extract operation:\r\n\r\n    $ xdm99.py work.disk -t -e HELLO-S\r\n    $ xdm99.py work.disk -9 -e HELLO-S\r\n\r\nBy default, files extracted in TIFiles or v9t9 format will have extension `.tfi`\r\nor `.v9t9`, respectively.\r\n\r\nTo add a file in TIFiles format or v9t9 format, add `-t` or `-9` to the add\r\noperation:\r\n\r\n    $ xdm99.py work.disk -t -a hello-s.tfi\r\n    $ xdm99.py work.disk -9 -a hello-s.v9t9\r\n\r\nNote that for safety reasons `xdm99` will not infer the file type automatically,\r\nso adding a FIAD file without `-t` or `-9` option will incorrectly store the\r\nfile metadata as part of the file contents.\r\n\r\nAs all information about the TI filename and the TI file format is retrieved\r\nfrom the FIAD meta data, parameters `-n` and `-f` are ignored when used in\r\ncombination with `-t` or `-9`.\r\n\r\n`xdm99` also handles \"short\" TIFiles used, e.g., by Classic 99.\r\n\r\n    $ xdm99.py work.disk -t -a HELLO-S\r\n\r\nShort TIFiles do not store TI filename and creation date, but use the host\r\nfilesystem information instead.  `xdm99` detects automatically if a given\r\nTIFiles file is in long or short TIFiles format.\r\n\r\nExtracted TIFiles are always in long format, but Classic 99 can use those files\r\njust as well if the extension `.tfi` is removed.  To simplify exchange with\r\nClassic 99, the `--ti-names` option will use the uppercase name without\r\nextension.\r\n\r\nThe info parameter `-I` displays the meta file information contained in FIAD\r\nfiles, while the print parameter `-P` dumps the file contents to\r\n`stdout`:\r\n\r\n    $ xdm99.py -I hello-s.tfi\r\n    $ xdm99.py -P hello-s.v9t9\r\n\r\n`xdm99` can also convert from FIAD files to plain files and vice versa without\r\nrelying on disk images using the `-T` and `-F` parameters:\r\n\r\n    $ xdm99.py -F hello-s.tfi\r\n    $ xdm99.py -T hello.a99 -f DIS/VAR80 -n HELLO-S -o hello-s.tfi\r\n\r\nNote that creating a FIAD file using the `-T` option usually requires\r\ninformation about the TI filename and the TI file type, similar to adding plain\r\nfiles to a disk image using `-a`.  When converting multiple files to FIAD\r\nformat, the TI filename supplied by `-n` is incremented automatically for each \r\nfile.\r\n\r\nFIAD file conversion `-T`, `-F` and information `-I` and `-P` infer the FIAD\r\nformat used automatically, but detection may be overridden with the `-t` or\r\n`-9` options.\r\n\r\n\r\n### Analyzing Disks\r\n\r\nThe check parameter `-C` analyzes a disk image for errors and prints a summary\r\nto `stderr`.  While all disk operations, including cataloging, also check and\r\nreport any disk errors found, the `-C` parameter restricts the output of `xdm99`\r\nto those errors only.\r\n\r\n    $ xdm99.py -C work.dsk\r\n\r\nThe `-C` parameter also causes `xdm99` to set its return value to non-zero for\r\nwarnings, making it simple to write shell scripts for batch processing bad disk\r\nimages.\r\n\r\nThe repair option `-R` tries to fix any disk errors, mostly by deleting\r\nerroneous files from it.\r\n\r\n    $ xdm99.py -R work.dsk\r\n\r\nThe repair operation is likely to cause data loss, so it's best to extract\r\nerroneous files beforehand or to specify an alternative output file with `-o`.\r\n\r\nThe `-X` or `--initialize` option creates a new, blank disk image, using an\r\noptional name provided by `-n`.\r\n\r\n    $ xdm99.py blank.dsk --initialize 720 -n BLANK\r\n\r\nThe size of the disk image is given by the number of sectors.  You may also use\r\na disk geometry string, which is any combination of the number of sides `<n>S`,\r\nthe density `<n>D`, and an optional number of tracks `<n>T`, where `<n>` is an\r\ninteger or the letters `S` or `D`.  If `<n>T` is missing, `40T` is assumed.\r\n  \r\n    $ xdm99.py blank.dsk -X DSDD\r\n    $ xdm99.py blank.dsk -X 1d2s80t\r\n\r\nNote that the disk format used by the TI 99 supports up to 1600 sectors per\r\ndisk.\r\n\r\nThe special geometry `CF` is used for disk images for the CF7+/nanoPEB devices\r\nand corresponds to 1600 sectors.\r\n\r\n    $ xdm99.py volume.dsk -X cf\r\n\r\nYou can combine `-X` with other parameters such `-a` to work with the newly\r\ncreated image immediately:\r\n\r\n    $ xdm99.py work.dsk -X SSSD -a file -f DV80\r\n\r\nThe resize parameter `-Z` will change the total number of sectors of\r\nthe disk without changing the contents of the files currently stored.\r\n\r\n    $ xdm99.py work.dsk -Z 720\r\n\r\nAn integer argument will not change the geometry information of the disk.  To\r\nchange both size and geometry, `-Z` also accepts a disk geometry string:\r\n\r\n    $ xdm99.py corcomp.dsk -Z dssd80t -o ti-80t.dsk  # convert to 80 tracks\r\n\r\nResizing fails if more sectors than the target size are currently in use.\r\n\r\nThe `--set-geometry` parameter explicitly sets the number of sides, the\r\ndensity, and the track information of the disk image.\r\n\r\n    $ xdm99.py work.dsk --set-geometry 2S1D80T\r\n\r\nNote that the `--set-geometry` command is rarely required for regular images\r\nbut may be helpful for experimenting with non-standard disk image formats.\r\n\r\nThe sector dump parameter `-S` prints the hexadecimal contents of individual\r\nsectors to `stdout`.  This can be used to further analyze disk errors or to save\r\nfragments of corrupted files.\r\n\r\n    $ xdm99.py work.dsk -S 1\r\n    $ xdm99.py work.dsk -S 0x22 -o first-file-sector\r\n    \r\nFor convenience, integer arguments of `-S`, `-X` and `-Z` may be specified in\r\neither decimal or hexadecimal notation.\r\n\r\n\r\nxhm99 HFE Image Manager\r\n-----------------------\r\n\r\nThe `xhm99` HFE image manager is an extension to the `xdm99` disk manager that\r\nis both a conversion tool and a manager for HFE images used by HxC floppy\r\nemulators.\r\n\r\n\r\n### Converting Images\r\n\r\nTo convert an existing disk image to an HFE image that can be copied onto an SD\r\ncard and used by the HxC floppy emulator, invoke `xhm99` with a single to HFE\r\n`-T` argument:\r\n\r\n\t$ xhm99.py -T work.dsk [...] [-o <filename>]\r\n\r\nThis yields the file `work.hfe` by default.  Instead of `-T` you may also use\r\nthe long format `--to-hfe`.\r\n\r\nSimilarly, the from HFE `-F` argument converts from HFE image back to disk\r\nimage:\r\n\r\n\t$ xhm99.py -F image.hfe [-o <filename>]\r\n\r\nThis yields the file `image.dsk` by default.  Instead of `-F` you may also use\r\nthe long formats `--from-hfe` or `--to-dsk`.\r\n\r\n\r\n### Managing Image Contents\r\n\r\nAll options other than `-F` and `-T` are similar to those of `xdm99` and operate\r\ndirectly on the disk image that is contained in the HFE image supplied.\r\n\r\nTo show the contents of a HFE image, simply invoke `xhm99` with the HFE filename\r\nand no further arguments.\r\n\r\n\t$ xhm99.py image.hfe\r\n    SOMEDISK  :     4 used  356 free   90 KB  1S/1D 40T  9 S/T\r\n    ----------------------------------------------------------------------------\r\n    SOMEFILE       2  DIS/FIX 60      60 B    1 recs  2016-08-18 20:50:12    \r\n\r\nTo show the contents of a file on the console, use the print argument `-P`.\r\n\r\n\t$ xhm99.py image.hfe -p SOMEFILE\r\n\tHello xdt99, meet HFE!\r\n\r\nYou may also add, extract, rename, or delete files:\r\n\r\n\t$ xhm99.py image.hfe -a manual.txt -f dv80\r\n\t$ xhm99.py image.hfe -r MANUAL:README\r\n\t$ xhm99.py image.hfe -e SOMEFILE -o greeting.txt\r\n\t$ xhm99.py image.hfe -d SOMEFILE\r\n\r\nTo create a new HFE image from a single FIAD file, combine the initialize option\r\n`-X` with the add file argument `-a` and the TIFiles option `-t`:\r\n\r\n\t$ xhm99.py new.hfe -X dssd -a somegame.tfi -t\r\n\r\nYou can also resize HFE images, e.g., if you want to create more free space:\r\n\r\n\t$ xhm99.py sssd_image.hfe -Z ssdd\r\n\r\nThe resize argument `-Z` can even change the number of tracks, e.g., converting\r\nfrom DSDD with 40 tracks to DSSD with 80 tracks:\r\n\r\n\t$ xhm99.py dsdd_image.hfe -Z dssd80t\r\n\r\nThe only format currently not supported is DSDD80T.\r\n\r\nFor further information about available arguments please refer to the `xdm99`\r\nsection above.\r\n\r\n\r\nxvm99 nanoPEB Volume Manager\r\n----------------------------\r\n\r\nThe `xvm99` volume manager is an extension to the `xdm99` disk manager that is\r\nboth a conversion tool and a manager for CF card volumes used by nanoPEB/CF7+\r\ndevices.\r\n\r\n\r\n### Managing Volumes\r\n\r\nThe default operation of `xvm99` when invoked without any command arguments is\r\nto print a short summary of the disk images stored in the specified volumes.\r\n\r\n    $ xvm99.py /dev/sdc 1-4,8\r\n    [   1]  EXTBASIC  :     4 used  1596 free\r\n    [   2]  EMPTY     :     2 used  1598 free\r\n    [   3]  SSSD      :    39 used  1561 free\r\n    [   4]  INFOCOM   :   459 used  1141 free\r\n    [   8]  (not a valid disk image)\r\n\r\nThe first argument is the name of your Compact Flash card drive, i.e., something\r\nlike `/dev/sdc` on Linux, `/dev/Disk3` on Mac OS X, or `\\\\.\\PHYSICALDRIVE2` on\r\nWindows.  **Caution:** These are examples only; make sure to identify your CF\r\ncard device correctly, *or you will lose data!* Also note that your user needs\r\nappropriate read and/or write permissions to access the device.\r\n\r\nThe second argument may be a single volume number or a combination of value\r\nranges, e.g., `1,3-4,6-10`.  In general, if more than one volume is specified,\r\nthen the command is applied to *all* volumes.\r\n\r\nThe `-w` argument writes a disk image to one or more volumes.\r\n\r\n    $ xvm99.py /dev/sdc 1,3 -w work.dsk\r\n\r\n`xvm99` automatically extends the disk image to match the 1600 sector format\r\nused by the CF7+ device, unless the `--keep-size` option is given.\r\n\r\nThe `-r` argument reads a disk image from a volume and stores it on the local\r\nfile system.\r\n\r\n    $ xvm99.py /dev/sdc 2 -r vol2.dsk\r\n\r\nWhen reading from multiple volumes the resulting disk images will be renamed\r\nautomatically.  `xvm99` trims disk images to match the sector count stored in\r\nthe image, unless the `--keep-size` option is given.\r\n\r\n\r\n### Manipulating Volumes\r\n\r\nMost commands provided by `xdm99` are also available for `xvm99`.\r\n\r\nFor example, to catalog a volume, you use the same `-i` command as for `xdm99`:\r\n\r\n    $ xvm99.py /dev/sdc 8 -i\r\n\r\nOther commands supported by `xvm99` are print files `-p`, extract files `-e`,\r\nadd files `-a`, delete files `-d`, check disk `-c`, and repair disk `-R`.\r\n\r\nAgain, if more than one volume is specified, then the command is applied to all\r\nvolumes.  For example,\r\n\r\n    $ xvm99.py /dev/sdc 1-20 -a README -f DV80\r\n\r\nadds the local file README to all disk images in volumes 1 through 20.\r\n\r\n\r\nExample Usage\r\n-------------\r\n\r\nThis section gives an example on how to assemble a TI 99 assembly program and\r\nrun it on the MESS emulator.  The commands entered and the responses shown here\r\noriginate from a Linux system, but they should look very similar on Windows and\r\nMac OS X machines.\r\n\r\nThe binary distribution of xdt99 contains an `example` folder with some sample\r\nfiles that we're going to use.  For the source distribution available on Github\r\nthese files are located under the `test` folder.\r\n\r\n    $ cd example/\r\n    $ ls -l\r\n    -rw-rw---- 1 ralph ralph  1822 Jan 10 12:51 ascart.a99\r\n    -rw-rw---- 1 ralph ralph   925 Jan 10 12:32 ashello.a99\r\n    -rw-rw---- 1 ralph ralph 92160 Jan 10 12:33 work.dsk\r\n    \r\nThe file `ashello.a99` contains a simple assembly program that we want to\r\nassemble and run.  Since the program uses register symbols like `R0` to refer\r\nto registers, we need to specify the `-R` option for assembly.\r\n\r\n    $ xas99.py -R ashello.a99\r\n\r\nThis should yield an object code file `ashello.obj` that looks like\r\nthis:\r\n\r\n    0007EASHELLO A0000B100DB4845B4C4CB4F20B574FB524CB4420B2020B68697F19FF       0001\r\n    A0012B7420B616EB7920B6B65B7921B0300B0000B02E0B8300B04C0B02017F2F9F          0002\r\n    A0028B2A20B0202B0300B0420B0000B0580B0602B16FBB0200B0043B02017F336F          0003\r\n    A003EC0002B0202B001AB0420B0000B0208BFF00B04C9B0300B0002B10007F31FF          0004\r\n    A0054B0300B0000BD809B837CBD809B8374B0420B0000B9220B8375B13F97F2D4F          0005\r\n    A006ABD020B8375B0980B0240B000FB0260B0700B0420B0000B10E87F410F               0006\r\n    50000SLOAD 50000SFIRST5007ESLAST 5001CSTART 30030VSBW  7F28AF               0007\r\n    30046VMBW  3007AVWTR  30062KSCAN 7F827F                                     0008\r\n    :       xdt99 xas                                                           0009\r\n \r\nThis file can be loaded with the Editor/Assembler module using option 3, or\r\nalternatively with the TI Extended BASIC module using the `CALL LOAD`\r\nstatement.\r\n\r\nUncompressed object code is not an efficient program format, though.  If\r\ncompatibility with Extended BASIC is not required compressed object code\r\nreduces both size and loading time:\r\n\r\n    $ xas99.py -R -C ashello.a99 - ashello-c.obj\r\n\r\nComparing both object files we see that the compressed version is only about\r\ntwo thirds of the size of the uncompressed file:\r\n\r\n    $ ls -l ashello*.obj\r\n    -rw-rw---- 1 user user 486 Jul 12 09:58 ashello-c.obj\r\n    -rw-rw---- 1 user user 729 Jul 12 09:58 ashello.obj\r\n\r\nTo save even more space, we'll also generate an image file for option 5:\r\n\r\n    $ xas99.py -R -i ashello.a99\r\n\r\nThis time we should get a binary file `ashello.img` of 132 bytes.\r\n\r\n    $ ls -l ashello.img\r\n    -rw-rw---- 1 ralph ralph   132 Jan 10 13:11 ashello.img\r\n\r\nWe now need to transfer these files to a TI disk image so that the TI 99\r\nemulated by MESS can load it.  We'll use the SS/SD disk image `work.dsk` that\r\nis included in the example folder of xdt99 for convenience:\r\n\r\n    $ xdm99.py work.dsk -a ashello.obj -n HELLO-O -f DIS/FIX80\r\n    $ xdm99.py work.dsk -a ashello.img -n HELLO-I\r\n    $ xdm99.py work.dsk\r\n    WORK      :     8 used  352 free   90 KB  1S/1D  40 TpS\r\n    ----------------------------------------------------------------------------\r\n    HELLO-I        2  PROGRAM        132 B            2015-01-10 13:15:18\r\n    HELLO-O        4  DIS/VAR 80     755 B    9 recs  2015-01-10 13:15:10\r\n\r\nWe start MESS with our work disk inserted in floppy drive 1:\r\n\r\n    $ mess64 ti99_4ae -peb:slot2 32kmem -peb:slot8 hfdc -cart EA.rpk -flop1 work.dsk\r\n\r\nYou may have to adjust the command for starting MESS based on the location of\r\nyour Editor/Assembler cartridge file.  When using a graphical frontend to launch\r\nMESS, use your GUI to select the Editor/Assembler module and the disk image\r\npreviously created.\r\n\r\nOn the TI 99/4A startup screen, we hit any key, then select the Editor/Assembler\r\nmodule.  We select option 3, `LOAD AND RUN`, then enter the name of the object\r\ncode file at the `FILE NAME?` prompt:\r\n\r\n    DSK1.HELLO-O\r\n\r\nOnce the loader finishes, we hit `ENTER` to advance to the `PROGRAM NAME?`\r\nprompt, and type `START` to start the program.  The words \"HELLO WORLD\" should\r\nappear on screen, and hitting any key will change the color of the screen\r\nborder.\r\n\r\nWhen done, we quit the program by hitting `FCTN =`.  Again we select the\r\nEditor/Assembler module, but now we select option 5, `RUN PROGRAM FILE`.  We\r\nenter the name of the image file:\r\n\r\n    DSK1.HELLO-I\r\n\r\nThe program will start automatically once loading has completed.\r\n\r\nIf we want to learn more about the internals of our assembled program we can\r\ntake a look at its list file: \r\n\r\n    $ xas99.py -R ashello.a99 -L ashello.lst\r\n\r\nThis yields a text file `ashello.lst` that begins like this:\r\n\r\n    XAS99 CROSS-ASSEMBLER   VERSION 1.2.3\r\n    0001            *  HELLO WORLD\r\n    0002            \r\n    0003                   IDT 'ASHELLO'\r\n    0004            \r\n    0005                   DEF SLOAD,SFIRST,SLAST,START\r\n    0006                   REF VSBW,VMBW,VWTR\r\n    0007                   REF KSCAN\r\n    0008            \r\n    0009            SLOAD\r\n    0010 0000 100D  SFIRST JMP  START\r\n    0011            \r\n    0012      8300  WRKSP  EQU  >8300\r\n    0013      8374  KMODE  EQU  >8374\r\n    0014      8375  KCODE  EQU  >8375\r\n    0015      837C  GPLST  EQU  >837C\r\n    0016            \r\n    0017 0002 ....  MESSG  TEXT 'HELLO WORLD'\r\n    0018 000D ....         TEXT '   hit any key!'\r\n    0019      001A  MESSGL EQU  $-MESSG\r\n    0020            \r\n    0021 001C 0300  START  LIMI 0\r\n         001E 0000 \r\n    0022 0020 02E0         LWPI WRKSP\r\n         0022 8300\r\n    ...\r\n\r\nThe first column shows the line number of our source file.  As we can see, some\r\nsource file lines may produce more than one list file lines.  The second and\r\nthird columns show the memory location and its contents, respectively.  Some\r\ndirectives such as `EQU` do not correspond to a memory location, so their\r\nsecond and third columns may show other relevant information instead.\r\n\r\nTo run assembly programs without the Editor/Assembler module, we finally\r\ngenerate our own self-contained cartridge.\r\n\r\nFirst we need to assemble our source code using the `-c` option.\r\n\r\n    $ xas99.py -R -c ascart.a99 -n \"HELLO CART\"\r\n\r\nNote that we cannot run the `ashello.a99` program as a cartridge, since we call\r\n`VSBW` and other VDP subroutines, which are unavailable without Editor/Assembler\r\nmodule and memory expansion.  The `ascart.a99` program thus uses the VDP\r\nregisters directly to write to VDP memory.\r\n\r\nWe don't have to transfer the resulting RPK file to a disk image but can plug\r\nthe cartridge directly into the MESS emulator:\r\n\r\n    $ mess64 ti99_4ae -cart ascart.rpk\r\n\r\nAfter pressing any key on the TI 99 startup screen you should now see \"HELLO\r\nCART\" as the second option on the menu screen.  Pressing 2 will run the sample\r\nprogram.\r\n\r\nNote that the programs runs without the 32K memory expansion, as the\r\nprogram code is stored inside a virtual cartridge ROM.\r\n\r\nIf we want to run our sample program on a real TI 99 using the CF7+ flash drive,\r\nwe need to transfer our disk image to a flash card first:\r\n\r\n    $ xvm99.py /dev/sdc 2 -w work.dsk\r\n\r\nThis will make our work disk from above available as volume 2 on the CF7+, where\r\nit can be accessed as `DSK2` by default on the TI 99.  If we don't want to\r\nreplace the entire disk contents of volume 2 we could also just transfer the\r\nfile instead.\r\n\r\n    $ xvm99.py /dev/sdc 2 -a ashello.obj -n HELLO-O -f DIS/FIX80\r\n\r\nEither way, `ashello.obj` will be available as `HELLO-O` in volume 2 and can\r\nloaded as `DSK2.HELLO-O` by the Editor/Assembler module.\r\n\r\n\r\n### Building Cartridges With GPL\r\n\r\nThis subsection shows how we can use the `xga99` GPL cross-assembler to assemble\r\nGPL programs into virtual cartridges that run in any TI 99 emulator.  (With the\r\nright device such as a GRAM Kracker this exercise would even work on a physical\r\nTI computer!)\r\n\r\nThe `example/` directory included with xdt99 contains a small GPL program\r\n`gahello.gpl` that sets some sprites in motion, shows a simple animation in\r\nnormal graphics mode, and plays a simple tune.\r\n\r\nIf you're using the MESS emulator running the sample program is very easy:\r\n\r\n    $ xga99.py -c gahello.gpl\r\n    $ mess64 ti99_4ae -cart gahello.rpk\r\n\r\nInside the TI 99 emulation, you'll find a menu entry for the cartridge program\r\non the TI menu selection screen.\r\n\r\nFor other emulators you'll probably need to work with the plain GPL image file\r\ninstead:\r\n\r\n    $ xga99.py -i gahello.gpl -G 0x6000 -A 0x20\r\n\r\nThis yields the file `gahello.bin` that contains the GPL byte code with suitable\r\nheader data for the GPL interpreter of the TI 99.  The `-G` and `-A` options\r\ntell `xga99` that we want to place the byte code into a cartridge GROM.\r\n\r\nTo run the sample program, load `gahello.bin` as a cartridge into your emulator\r\nand reset the virtual TI 99.  Again, you should find an entry for the program on\r\nthe TI menu selection screen.\r\n\r\n\r\nFeedback and Bug Reports\r\n------------------------\r\n\r\nThe xdt99 tools are released under the GNU GPL, in the hope that TI 99\r\nenthusiasts may find them useful.\r\n\r\nPlease email feedback and bug reports to the developer at <xdt99dev@gmail.com>\r\nor use the issue tracker on the project [GitHub page][2].\r\n\r\n\r\n[1]: https://endlos99.github.io/xdt99\r\n[2]: https://github.com/endlos99/xdt99\r\n[3]: https://github.com/endlos99/xdt99/releases\r\n[4]: https://github.com/endlos99/xdt99/blob/master/WINDOWS.md\r\n[4]: https://github.com/endlos99/xdt99/releases\r\n[5]: https://www.python.org/downloads/\r\n[6]: http://www.mizapf.de/ti99/tiimagetool.html\r\n[7]: http://www.99er.net/win994a.shtml\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}